ოპერაციულმა სისტემამ ჩაგვიტვირთვა PE (Portable Execution) ფაილი ან .NET assembly როგორც გინდათ ისე მოიხსენიეთ CLR-ში , უკვე აქედან იწყება უკვე Runtime , პირველ რიგში რა არის ეს Runtime?

Runtime - Runtime არის გარემოსა და ამ გარემოში შემავალი სისტემის ისეთი კომპონენტები , რომლებიც პასუხისმგებელნი არიან პროგრამის გაშვებაზე . Runtime არის პროცესი , რომელიც გრძელდება პროგრამის დაწყებიდან დასრულებამდე .

- გარემო - Runtime-ის კონტექსტში გარემო არის ჩვენს მიერ გაშვებული პროგრამის მთლიანი კონტექსტი ან პლატფორმა და მასში მოთავსებულია ყველაფერი რაც საჭიროა ამ პროგრამის გასაშვებად(Runtime engine , OS info, hardware info, libraries and framework , `ect..`).
- სისტემის კომპონენტები - არის გარემოში არსებული ცალკეული მოდულები , რომლებიც კონკრეტულ ფუნქციონალს გვაძლევენ იმისათვის რომ პროგრამის გაშვება გახდეს შესაძლებელი (JIT Compiler , Garbage Collector , Security Manager , Thread Manager , Other libraries).


## CLR Introduction

.NET ის პროდუქტების მთავარი Runtime ძრავი არის ცნობილი როგორც CLR (Common Language Runtime) . CLR ხშირად ეძახიან ვირტუალურ მანქანას და პარალელის გავლებას ცდილობენ JVM-თან (Java Virtual Machine) , მაგრამ CLR JVM-ისგან განსხვავდება იმით რომ მას არ ადარდებს თუ რომელ დაპროგრამების ენასთან მუშაობს , კომპილერი ყოველთვის CIL მისცემს მას , მაგრამ JVM მხოლოდ ჯავაზე მუშაობს , 

**ისტორიის მიმოხილვა**
სანამ ეს შუამდგომელ ენაში (IL) გადათარგმნა გვექნებოდა პროგრამების უმეტესობა იწერებოდა ისეთ დაპროგრამების ენემბში სადაც დაკომპილირებული კოდი პირდაპირ მანქანის ინსტრუქციებში გადადიოდა . ეს მიდგომა გვაძლევდა უფრო დაბალი დონის კონტროლს კომპონენტებზე და ასევე წარმადობითაც ისინი დღესაც ძალიან პოპულარულნი არიან ( C / C++) , მაგრამ მათ თავიანთი მინუსები გააჩნდათ მაგალითად : დაპროგრამების ენები განსხვავებულ მანქანის კოდს ქმნიდნენ და მათი შეთავსება რთული იყო , ისინი დამოკიდებულნი იყვნენ პროცესორსა და ოპერაციულ სისტემებზე , დეველოპერს მეხსიერების მათვა თვითონ უწევდათ , განსხვავებულ აპპლიკაციებს განსხვავებული Runtime ბიბლიოთეკები ან DLL-ები სჭირდებოდათ რაც კომპლექსური იყო.

პირველად შუამგომელი ენის ფუნქციონალი ჩაინერგა დაპროგრამების ენა BCPS (Basic Combined Programming Language) იყო რომელიც 1960-იან წლებში შემუშავდა ეს კოდი გადასატანად შედარებით მარტივი გახადეს  და მისი შუამდგომელი კოდის სახელი O-code იყო, 1970-იან წლებში დაპროგრამების ენა Pascal-მა შემოიღო თავის შუამდგომელი კოდი რომელსაც P-code ეწოდა , მალევე SmallTalk-მა გამოუშვა  თავის შუამდგომელი კოდი რომელსაც Bytecode ეწოდა და ეს გახდა მომავალში Java-ს Bytecode-ის ფუძე რომელიც 1990-იან წლებში შეიქმნა და უკვე თანამედროვე Bytecode და JVM შემოგვთავაზა და ბოლოს მოვედით .NET CLR-ზე  რომელიც 2000 იან წლებში გამოვიდა , შუამდგომელ კოდს IL (Intermediate Language) უწოდეს და მისი მთავარი უპირატესობა იყო ის რომ დაპროგრამების ენისგან გამოუკიდებელი გახდა.


## CLI

CLI - CLI იგივე რაც Common Language Infrastructure არის გახსნილი სპეციფიკაცია და ტექნიკური სტანდარტების ნაკრები . შემქნელი არის მაიქროსოფთის მიერ და ის რეალურად აიმპლემენტირებს ორ მნიშვნელოვალ სტანდატიზაციას ესენია

- ISO/IEC 23271 - არის სტანდარტიზაციის საეთაშორისო ორგანიზაციისა და საერთაშორისო ელექტროტექნიკური კომიის გაერთიანება.
- ECMA-335 - არის სტანდარტიზაცია , რომელიც განსაზღვრავს ტექნიკურ სპეციფიკაციას runtime გარემოსთვის , რომელიც საშუალებას გვაძლევს რომ განსხვავებულ მაღალი დონის დაპროგრამების ენებზე დაწერილი აპლიკაციები გაშვებულიყოს განსხვავებულ კომპიუტერულ პრათფორმებზე კოდზე შეუხებლად.



## CLR Core / Help-full services

CLR-ს მრავალი მნიშვნელოვანი საქმე აკისრია ის ზოგადად არის Runtime-ის მნიშნელოვანი სერვისების კომბინაცია , მაგრამ მე მაინც დავყოფ მათ ორ ნაწილად : Core , Help-full services.

**Core**
ზოგადად აუცილებელია რომ CIL გარდაიქმნას მანქანის კოდად ამის გამო მე Core კატეგორიაში ჩავსვავ   JIT Compiler (Just in time Compiler) , Assembly Loader და Class Loader . JIT საჭიროა იმისთვის რომ მანქანის კოდად გარდაქმნა მოხდეს და Assembly Loader-სა და Class Loader-ის გარეშე JIT ვერ იმუშავებს.

**Help-full services**
CLR-ს მოყვება მრავალი ძალიან დამხმარე სერვისი , როგორიცაა Garbage Collector , Security Manager , Exception Handling , Thread Manager , Interop Service , Metadata and Reflection , ეს სერვისები ძალიან საჭიროა და დიდ დროს აგებინებს დეველპერებს მაგრამ მათ გარეშეც შეიძლება მუშაობა


## Assembly Loader

**Assembly Loader** - არის CLR-ის ერთ ერთ მთავარი კომპონენტი , რომელიც პასუხისმგებელია ოპერატიულ სისტემაში Assembly-ის ჩატვირთვაში, ის ასევე  ამზადებს Assembly-ის რათა მომავლში მოხდეს მასში არსებული metadata-ს და IL-ის წაკითხვა.  Assembly Loader-არ არის რაიმე კლასი მისი გამოძახება რომ შევძლოთ ის CLR-ში (clr.dll) არის ჩაიმპლემენტირებული და მასთან შეხება შეგვიძლია ისეთი მაღალი დონის API-ებით როგორიცაა 

`Assembly.Load("MyAssembly");`
`Assembly.GetExecutingAssembly();`
`AppDomain.CurrentDomain.AssemblyResolve += ...`

როგორ ხდება მისი ინიციალიზება?

ოპერაციული სისტემა ჩატვირთავს mscoree.dll-ს , რომელიც ჩატვირთავს clr.dll-ს და აქ იწყება მთლიანი CLR-ის ინიციალიზება 

               YourApp.dll
                    ↓
           OS loads mscoree.dll
                    ↓
           mscoree calls into clr.dll
                    ↓
          CLR initializes subsystems:
            ├─ JIT Compiler
            ├─ Garbage Collector
            ├─ Execution Engine
            ├─ 🧠 Assembly Loader ← (we are here)
            └─ Class Loader, Security, etc.

ეს არის ინიციალიზების თანმიმდევრობა , არ მინდა რომ დაიბნეთ ეს არ არის გამოყენების თანმიმდევრობა

- ინიციალიზება != თანმიმდებრობას

Assembly Loader-ის ინიციალიზების შემდეგ ის იწყებს საჭირო Asslemby-ების ჩატვირთვას , ეს ხდება მაშინ როდესაც  მთავარი Assembly იტვირთება მ იგივე რაც ჩვენი აპლიკაციის DLL ფაილი ან რაიმე ისეთი ტიპი თუ იქნა გამოყენებული რომელიც ჯერ არ გამოგვიყენებია , შესაძლებელია assembly-ის ჩატვირთვა მოხდეს მაშინაც თუ ჩვენ ვიყენებთ ისეთ მეთოდებს როგორიცაა `Assembly.Load(...)` ან უფრო ხშირ შემთხვევაში ტიპთან `GetType(..)` მეთოდის გამოყენებისას

CLR-მა უნდა იცოდეს თუ რომელი Asembly-ჩატვირთოს Assembly Loader-ი სწორედ ამ შემთხვევებში ეხმარება მას და იდენტობას აძლევს Assembly-ებს რაც გულისხმობს შემდეგს :

- Name (e.g., `JaniApplication.Application`)
    
- Version
    
- Culture (e.g., `neutral`, `en-US`)
    
- Public Key Token (for strong-named assemblies)

კოდის მაგალითი მოვიყავნოთ , სადაც ზემოთ ნახსენებ მაღალი დონის API-ს ვიყენებთ

`Assembly.Load("MyLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=abc123...");`

იმისათვის რომ სისტემამ გაიგოს თუ რომელ assembly-ს ვეძახით მას ვაწვდით იდენტობის ამოსაცნობ ინფორმაციას.

Assembly Loader-ი ასევე პასუხისმგებელია სწორი `.dll` და `.exe` პოვნაში , რომლისთვისაც ის იყენებს რამოდენიმე რამეს ესენია: 
- აპლიკაციის საკვანძო დირექტორია
    
- `.deps.json`-ფაილში მითითებული მისამართები
    
- NuGet package-ში გაწერილი ლოკაციები
    
-  `AssemblyLoadContext` ან `AssemblyResolve` fallback event-ს

საინტერესო ის არის რომ თვითონ PE ფაილის ვალიდაციასაც Assembly Loader-ი უმკლავდება ანუ თუ რაღაცით ვინდოსს უჩვეულო დეტალი გამორჩა მას დამატებით შეამოწმებს Assembly Loader-ი და დარწმუნდება რომ ვალიდური .NET assembly-ისთან აქვს საქმე და რომ CLR Header-ი სწორად არის გაწერილი.

აქვე მინდა ვახსენო Assembly Loader-ის კავშირი metadata-სთან , ის წაიკითხავს metadata-ს სექციებს რომლებიც PE ფაილში იყო და მათ დამაპავს ოპერატიულ მეხსიერებაში ოპერატიული მეხსიერების API-ების გამოყენებით (`მაგ .. CreateFileMapping`)  . metadata-ს სპეციალურ სექციებს ეძებს CLR Header-ში არსებული ფოინთერებით და იქ არსებულ ცხრილებს უკეთებს ინდექსირებას რათა მათთან წვდომა უფრო სწრაფი გახდეს . შედეგად ჩვენ ვიღებთ დაბალი დონის თითქოს C++-ზე დაწერილ stuck-ებსა და მასივებს , რომლებიც შემდეგ გამოიყენებიან სხვადასხვა ინფომრაციის წამოსაღებად
## Class Loader 

.NET-ში Class Loader-არ არის საჯარო კომპონენტი როგორც ეს Java შია , ის არის CLR-ის შიგნით არსებული სერვისი  , რომელიც პასუხისმგებელია ტიპების ჩატვირთვასა და მათ გამზადებაზე , ეს ყველაფერი ხდება metadata-ს ცხრილებიდან , აპლიკაციაში რაიმე ტიპის პირველად გამოძახების შემდეგ.

**Class Loader-ი არის CLR-ში ჩაშენებული ტიპების სიტემის ნაწილი და მისი სამეა რომ აღმოაჩინოს , წაიკითხოს , დააზუსტოს და გაამზადოს ტიპები Runtime-ში წარსადგენად.**

მარტივად რომ შედავარო Assembly Loader და Class Loader ძალიან არიან ერთმანეთთან დაკავშირებულნი , პირველ რიგში Assembly  Loader ჩატვირთავს assembly-ს მაგალითად `.dll` ხოლო Class Loader ჩატვირთავს ამ ფაილში არსებულ `.cs` კლასებს 

**მაგალით**

ავიღოთ კოდის ეს მონაკვეთი

class Program
{
    static void Main()
    {
        `var user = new User();`
        `Console.WriteLine(user.Name);`
    }
}

public class User
{
    `public string Name { get; set; } = "Anri";`
}


პირველ რიგში იტვირთება Assembly (ამას Assembly Loader აკეთებს) , თუ User ის კლასი ჩატვირთული არ არის ამ შემთხვევაში Assembly Loader იპოვის ამ კლასის `.dll` ფაილს და მას ჩატვირთავს ოპერატიულ მეხსიერებაში ამის შემდეგ ეს უკვე ამ კლასის metadata ხელმისაწვდომი გახდება Class Loader-ისთვის. CLR დაინახავს თუ არა ამ კოდის ხაზს `var user = new User();` ის შეამოწმებს აქვს თუ არა ამ User კლასის Runtime სახის წარმოდგენა , თუ არა მას Class Loader აუწობს , ავხსნი როგორ

პირველ რიგში ის იპოვის TypeDef ჩააწერს Metadata ცხრილში , წაიკითხავს მის ფილდებს , მეთდებსა და თვისებებს , მისი ყოველი მეთოდისთვის შეინახავს metadata ტოკენს (მაგ. 0x06000001).

ამის შემდეგ ის ააწყობს საკუთარ Runtime სტრუქტუეას სადაც მას ექნება შემდეგი
- `EEClass` -  წარმოადგენს მთლიანი User ტიპის metadata-ს
- `MethodTable` -  შეიცავს ცვლადებს , მეთდის სლოტებს , Garbage Collection აგებულებას და ინტერფეისის სურკას
- `FieldDesc[]` - ინახავს ინფორმაციას Name ფილდის შესახებ 
ეს ყოველივე არის შიგნით ჩაშენებული CLR-ში

როდესაც ტიპი მზად არის იქმნება `TypeHandle-ი `, რომელშიც ქეშირდება ამ ტიპზე ყველა ინფორმაცია , ამის შემდეგ როდესაც დაგვჭირდება ამ კლასის ტიპის გამოყენება შემდეგ ყოვლეთვის მივწდებით `Cached MethodTable-ის` რეფერენსით 
## JIT 

JIT- JIT იგივე რაც Just in time არის ერთგვარი იდეოლოგია , რომელიც თავიდან გამოიყენებოდა მწარმოებლობაში .  მისი დამაარსებელია კომპანია Toyota და მას თავიდან Toyota Production System (TPS) სტილი ეწოდა. 

მთავარი იდეა არის შემდეგი , არ გააკეთო საქმე იქამდე სანამ ის აუცილებლად არ არის საჭირო.

ეს მწარმოებლობის მხრივ ნიშნავს რომ მაგალითად , მაღაზიაში საკვები პროდუქტი მოგივიდეს , მაღაზიის გახსნისას ან  რაღაც სამწარმოში სპეციალური ნაწილი მოგივიდეს სწორედ მაშინ როდესაც გჭირდება , ანუ ინვერნტარის შენახვა და მისი მოვლა აღარ გიწევს .

სწორედ ეს იდეოლოგია დევს JIT Compilation-ში

JIT Compiler- JIT Compiler, ანუ "უბრალოდ დროული" კომპაილერი, არის CLR-ის (Common Language Runtime) მთავარი ნაწილი, რომელიც პასუხისმგებელია CIL-ის (Common Intermediate Language) მშობლიურ მანქანურ კოდად (native code) გარდაქმნაზე გაშვების დროს (runtime). როდესაც .NET პროგრამა იწყება, JIT კომპაილერი იღებს CIL-ში დაკომპილირებულ კოდს, აანალიზებს მეტადატას (რომელიც აღწერს კოდის სტრუქტურას), და თარგმნის მას ინსტრუქციებად, რომლებიც შესაფერისია კონკრეტული პროცესორისთვის (მაგ., x86, x64). ეს თარგმანი ხდება "უბრალოდ დროულად", ანუ ჩვეულებრივ მაშინ, როცა კოდის გარკვეული ნაწილი (მაგ., მეთოდი) პირველად გამოიძახება, რის შემდეგაც გენერირებული მშობლიური კოდი ინახება მეხსიერებაში, რათა მომავალი გამოძახებები უფრო სწრაფი იყოს. JIT-ის მთავარი უპირატესობა ისაა, რომ ის აერთიანებს მაღალი შესრულების უპირატესობას (მშობლიური კოდის მსგავსად, როგორც C++-ში) და მოქნილობას, რადგან თარგმანი ხდება განთავსების მანქანაზე, რაც უზრუნველყოფს კოდის ადაპტაციას იმ გარემოზე, სადაც ის მუშაობს. გარდა ამისა, JIT საშუალებას იძლევა ოპტიმიზაციები განხორციელდეს გაშვების დროს, მანქანის სპეციფიკური მახასიათებლების გათვალისწინებით.

მაგალითი

შევხედოთ Main მეთოდს და განვიხილოთ დეტალურად თუ როგორ გაუმკლავდება მას JIT Compiler-ი 

`static void Main(){`
	`Console.WriteLine("Hello");`
	`Console.WriteLine("Goodbye");`
`}`

სანამ JIT კომპაილერი მუშაობას დაიწყებს ყველა საჭირო Assebly-ის ჩატვირთავს Assembly Loader-ი . ამის შემდეგ იწყება ამ ხაზის განხილვა `Console.WriteLine("Hello");` , მოდით ეტაპობრივად განვიხილოთ თუ რას იზამს JIT კომპაილერი

- JIT კომპაილერი იპოვის იმ assebly-ის რომელიც აიმპლემენტირებს ტიპ Console-ს , შემდეგ იპოვის მასში მეთოდს სახელად `WhiteLine` , რომელიც გამოძახებულია Metadata-ში.
- Metadata-დან წამოიღებს ამ მეთდისთვის შესაფერის IL-ს
- მეხსირებაში გამოყოფს სპეციალურ ადგილს ოპერაციის შესასრულებლად.
- გარდაქმნის IL მანქანის კოდად და ამ გარდაქმნილს შეინახავს ზემოთ ნახსენებ გამოყოფილ მეხსიერებაში.
- მეთოდის დასაწყისის წერტილს ცვლის ტიპების ცხრილში და მას მიმართავს ზემოთ გამოყოფილ მეხსირების ბლოკზე
- უშვებს თავის მიერ გარდაქმნის მანქანის კოდს.

![[Pasted image 20250712120637.png]]

ამის შემდეგ დაიწყება შემდეგი ხაზის განხილვა
`Console.WriteLine(“Goodbye”);`

ამ კოდის ხაზის განხილვა განსხვავებულად მოხდება
- JIT Compiler-მა უკვე იცის თუ რომელ ტიპთან და მეთოდთან აქვს საქმე , შესაბამისად ის გადაახტება ზემოთ აღწერილი ნაბიჯეჯებს.
- ზემოთ ნახსენები ეტაპებიდან მეხუთე ნაბიჯის დახმარებით პირდაპირ ოპერატიულ მეხსიერებაში ჩაშენებული მანქანის კოდი გაეშვება

![[Pasted image 20250712120705.png]]



