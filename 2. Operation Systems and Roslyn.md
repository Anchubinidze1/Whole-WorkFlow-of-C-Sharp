Roslyn-ის კომპაილერი საბოლოოდ გვიბრუნებს **PE ფაილს**, რომელიც შემდგომ გადაეცემა CLR-ს, რათა დამატებითი ოპერაციები ჩატარდეს მასზე. თუმცა, სანამ CIL გადაეცემა CLR-ს, მცირე ჩარევა ხდება ოპერაციული სისტემის მხრიდან. ამ თავში განვიხილავ, თუ როგორ მუშაობენ სხვადასხვა ოპერაციული სისტემები PE ფაილთან.

## PE ფაილი

**PE** (Portable Executable) ნიშნავს პორტატულ შესრულების ფაილს. PE ფაილს ზოგჯერ მოიხსენიებენ როგორც **Managed Module** (როდესაც მას მხოლოდ მოდულის ფუნქცია აქვს), ან როგორც **.NET Assembly** (როდესაც მას აქვს Manifest და დამატებითი ინფორმაცია). PE ფაილში მოთავსებულია შემდეგი კომპონენტები:

- CIL
    
- .NET Metadata Tables
    
- CLR Header
    
- Resources / Manifest
    

### ძირითადი კომპონენტების აღწერა:

- **CIL** – _(Common Intermediate Language)_, ასევე ცნობილი როგორც IL ან MSIL, არის შუამდგომელი ენა, რომელსაც აგენერირებს კომპაილერი. ის საერთო აქვს ყველა .NET-ის დაპროგრამების ენას. შესაბამისად, ყველა კომპაილერი, რომელიც CLR-ისთვისაა შექმნილი, აბრუნებს CIL-ს. CIL არის გარემოსგან დამოუკიდებელი და მუშაობს ნებისმიერ ოპერაციულ სისტემასთან და პროცესორის არქიტექტურასთან.
    
- **.NET Metadata Tables** – ეს არის ცხრილები, რომლებიც აღწერენ ჩვენი კოდის სტრუქტურას: კლასებს, მეთოდებს, პარამეტრებს, ფილდებს და ა.შ. მათი როლი მნიშვნელოვანია CLR-ისთვის, თუმცა ამაზე მოგვიანებით უფრო დეტალურად ვისაუბრებთ.
    
- **CLR Header** – სპეციალური სტრუქტურა, რომელიც ეუბნება ოპერაციულ სისტემას (ძირითადად Windows-ს) ან .NET runtime-ს, თუ როგორ უნდა მოექცეს PE ფაილს. მასში მითითებულია, რომელი CLR-ის ვერსიაა საჭირო, სადაა განთავსებული შესასვლელი წერტილი (Main მეთოდი), PE ფაილის ზომა, ლოკაცია, რესურსები და სხვა.
    
    მაგალითად, CLR Header ეუბნება:
    
    > "ეს ფაილი არ არის ჩვეულებრივი შესრულებადი ფაილი. ის .NET Assembly-ა და საჭიროა CLR-ის გამოყენება."
    
- **Manifest** – ასევე ცნობილი როგორც Assembly Manifest, შეიცავს .NET Assembly-ის შესახებ ინფორმაციას, როგორიცაა assembly-ის სახელი, ვერსია, კულტურა (ლოკალიზაცია), რეფერენსები სხვა assemblies-თან და ა.შ.
    
- **Resources** – ეს არის არა-კოდური მონაცემები, მაგალითად: string-ები, სურათები, ფაილები, ორობითი blobs და სხვა.
    

---

## Assembly-ის შესახებ

CLR არ მუშაობს ცალკეულ მოდულებთან – ის მუშაობს assembly-თან. Assembly არის რთული აბსტრაქტული ცნება, ამიტომ მნიშვნელოვანია მისი სწორად გაგება:

### ფიზიკური თვალსაზრისით:

Assembly არის ერთი ან მეტი მოდულისა და რესურსის ფაილის ლოგიკური ერთობლიობა.

უფრო დეტალურად:

- ფიზიკურად, Assembly არის `.dll` ან `.exe` ფაილი, რომელიც შეიცავს CIL კოდს, metadata-ს, Manifest-ს და რესურსებს.
    
- მოდული არის დაკომპილირებული .NET ფაილი, რომელიც შეიცავს CIL-ს და metadata-ს. მისი გაფართოებაა `.netmodule`. მოდულს არ აქვს საკუთარი Manifest, შესაბამისად, მისი დამოუკიდებლად გაშვება ან დარეფერენსება შეუძლებელია.
    
- უმეტეს შემთხვევაში ერთ assembly-ში გვაქვს ერთი მოდული, თუმცა შესაძლებელია რამდენიმე მოდულიც იყოს.
    

შესაბამისად, მოდული არის Assembly-ის შემადგენელი ნაწილი.

### ყველაზე პატარა ერთეულის თვალსაზრისით:

Assembly არის ხელახალი გამოყენების, დაცვისა და ვერსიირების უმცირესი ერთეული:

1. **ხელახალი გამოყენების ერთეული** – თუ სხვა პროექტში არსებული კლასის ან მეთოდის გამოყენება გვსურს, ვერ დავარეფერენსებთ პირდაპირ `.cs` ფაილს. ამისთვის აუცილებელია მთლიანი assembly-ის (`.dll`) დარეფერენსება. მაგალითად, NuGet პაკეტები სწორედ assemblies-ებს შეიცავს.
    
2. **დაცვის ერთეული** – .NET-ში დაცვის საზღვრები განისაზღვრება assembly-ის დონეზე. ადრე ამისთვის გამოიყენებოდა CAS _(Code Access Security)_, რომელიც დღეს ჩანაცვლებულია თანამედროვე მეთოდებით (OS-level sandboxing, Role-based & policy-based authorization და სხვ.).
    
3. **ვერსიირების ერთეული** – Assembly-ს მიენიჭება ვერსიის რიცხვი, არა ცალკეულ კლასს ან მეთოდს. მაგალითად, თუ აპლიკაცია იყენებს LoggingLib v1.0-ს, მისი 2.0 ვერსიის გამოყენებისთვის აუცილებელია აპლიკაციის თავიდან დაკომპილირება ან binding-redirect-ის გამოყენება.
    

---

## Windows-ზე PE ფაილის დამუშავება

PE ფაილები ორი ტიპისაა: **PE32** (32-bit) და **PE32+** (64-bit).

- PE32 მუშაობს 32-ბიტიან და 64-ბიტიან Windows-ზე.
    
- PE32+ მუშაობს  64-ბიტიან Windows-ზე და ARM64-ზე.
    

.NET Framework SDK შეიცავს CLI ინსტრუმენტს – `CLRVer.exe`, რომელიც გვაჩვენებს სისტემაში CLR-ის ვერსიებს და ამჟამად გამოყენებულ ვერსიას.

### Windows Loader-ის მოქმედებები:

Windows Loader არის ოპერაციული სისტემის ნაწილი, რომელიც:

1. ქმნის პროცესს (`CreateProcess`) – გამოყოფს მეხსიერებას, ამზადებს მთავარ Thread-ს, Stack-ს და გარემოს ცვლადებს.
    
2. კითხულობს PE header-ს – არკვევს პროცესორის არქიტექტურას (Machine field), იყენებს Section tables-ს, რათა განსაზღვროს `.text`, `.data`, `.rdata` და სხვა სექციების მეხსიერებაში განთავსება.
    
3. წყვეტს DLL-ების იმპორტს – იყენებს Import Table-ს DLL-ების ჩასატვირთად.
    
4. CLR Header-ის აღმოჩენის შემთხვევაში – ჩატვირთავს `mscoree.dll`-ს და გამოძახებს `_CorExeMain()` მეთოდს, რის შემდეგაც იტვირთება CLR.
    

---

## macOS / UNIX-ზე PE ფაილის დამუშავება

macOS და Unix სისტემები ვერ კითხულობენ PE ფაილებს. შესაბამისად, `.exe` და `.dll` ფაილების უშუალოდ გაშვება შეუძლებელია და საჭიროა runtime host-ის გამოყენება.

მოკლე ეტაპები CLR-მდე:

1. **აპლიკაციის მექანიკური გაშვება**  
    საჭიროა CLI-ით მიმართვა:
    
    bash
    
    CopyEdit
    
    `dotnet MyApp.dll`
    
2. **`dotnet` CLI-ის გაშვება**  
    `dotnet` არის .NET SDK-სთან ერთად ჩაწერილი binary (bootstrapper), რომელიც ანაცვლებს Windows-ში არსებულ `mscoree.dll`-ს.  
    _Bootstrapper არის პროცესი, რომელიც რთული სისტემის გაშვებას უზრუნველყოფს._
    
3. **`hostfxr`-ის გაშვება**  
    `dotnet` CLI იძახებს Host Framework Resolver (`hostfxr`)–ს.
    
    - Unix: `libhostfxr.so`
        
    - macOS: `libhostfxr.dylib`
        
    
    `hostfxr` პოულობს runtime-ის საჭირო ვერსიას, ტვირთავს მას, რის შემდეგაც იწყება CoreCLR-ის ოპერაციები.