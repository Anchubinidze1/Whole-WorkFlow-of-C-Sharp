
გამონაკლისების დამუშავება არის CLR-ის კიდევ ერთი სერვისი , რომელიც გვეხმარება ისეთი პრობლემების აღმოსაჩენად , რომლებიც ჩნდება კოდის გაშვების შემდეგ ამას Runtime error-ები ეწოდება.

## ისტორია

სანამ პროგრამებში გამონაკლისების დამუშავება გვექნებოდა ერორების დამუშავება ხდებოდა მექანიკურად . ეს ხდებოდა ერორის კოდების გამოყენებით (მაგალითად : -1 , NULL) , ასევე გამოყენებული იყო `goto` განცხადებები ,  რომლებიც გადახტებოდნენ ასაწმენდ კოდზე შეცდომისას.
ასევე სტატუსის ფლეგებიც იყო გამოყენებული (მაგ : `errno` C-ში).

ჯამში ვიღებდით რაღაც ასეთ კოდს

`int result = doWork();`
if (result == -1) {
    // შემოწმდება ერორები
    // შეინახება ამ ერორის ჩანაწერები
    // რესურსის გამსუფთავებელი
    return -1; // შესაბამისის ერორის კოდის დაბრუნება
}

კოდი რაც უფრო იზრდებოდა მით უფრო რთული იყო ამ სტრუტურის გამოყენება და შენარჩუნება.


შემდეგ პირველად LISP-ში გვხდება სტრუქტურული გამონაკლისების დამუშავების სტრუქტურა ,სადაც შედარებით უკდეთესი ერორების სიგნალის და დამუშავების ხერხები გვხდება რადგან იქ განცხადების სისტემა იყო ჩანერგილი , რომლის იდეაც იყო ნორმანული და გამონაკლისთა დამუშავების ლოგიკის განცალკევება.

შემდეგი განვითარების ეტაპი უკვე 1970-1980-იან წლებში იყო სადაც უკვე დღეისთვის ნაცნობი სახე მიიღეს გამონაკლისების დამმუშავებლებმა მაგალითად : Ada დაპროგრამების ენაში გვხდება პირველი რეალური try-catch მოდელი , რომელიც ენის ნაწილი იყო. C++ ში უკვე გვხდება try , catch , throw საკვანძო სიტყვები რომლებიც გამონაკლისების დამუშავებისთვის არის შექმნილი .  ასევე დაამატა Stack unwinding , destructors და type-based dispatch-ი.


- **Stack unwinding** - არის პროცესი , რომელიც ხდება გამონაკლისთა დამუშავებისას . გამონაკლისის პოვნისას Runtime-ი ცდილობს Thread-ის Call stack-ში Try-Catch-ის ბლოკის პოვნას თუ ვერ იპოვა შესაბამისი Catch ბლოკი მაშინ პროგრამა დაიქრაშება

1995 წელს უკვე ჯავამ შემოიტანა შემოწმებული გამონაკლისების ცნება , სადაც დეველოპერებს უწევთად მიეთითებიათ თუ რა სახის გამონაკლისი შეიძლება გამოეწვია კონკრეტულ მეთოდს. 

მოგვიანებით .NET-ისა და CLR-ის შექმნისას , იმისათვის რომ გაეუმჯობესებიათ გამონაკლისების მოგვარების პრობლემა გააერთიანეს C++/Java .


## Exception Handling and Task Class

როდესაც გამონაკლისების მოგვარებას განვიხიხლავდი ძალიან დამაინტერესა ერთმა შეკითხვამ . ვთქვათ გვაქვს ასეთი შემთხვევა


static async Task Main()
{
    try
    {
        await Task.Run(() =>
        {
            throw new Exception("Caught!");
        });
    }
    catch (Exception ex)
    {
        Console.WriteLine("Handled it: " + ex.Message);
    }

    Console.WriteLine("This line *will* run.");
}


ცალკეულ Thread-ზე ვუშვებთ მეთოდს რომელიც ისვრის გამონაკლისს , როგორ ხდება რომ Thread-ი ერთიდან მეორეში აძლევს ამ გამონაკლისს , მე წინა თავებში უკვე აღწერე რომ Thread-ებს შორის ინფორმაციის გაცვლა არც თუ ისე მარტივი ოპერაციაა ის ოპერაციული სისტემისგან არის შეზღუდული. როგორც ჩანს ამას თვითონ Task კლასი აგვარებს თუ Runtime-მა დაინახა რომ გამონაკლისის დაჭერა ვერ მოხერხდა ამ Thread-ზე მაშინ ის მას გადასცემს იმ Thread-ს რომელიც იძახებს ამ გამონაკლისის მსროლელ მეთოდს. და იქ ცდის მის მოგვარებას .

ზოგადა try/catch- არის შექმნილი კომპაილერისა და Runtime-ისთვის , რომ ეს კოდის ბლოკი ისე დაამუშაონ რომ გამონაკლისის დაჭერა მოხდეს .

მაგალითად ვართ მეთოდში :

static async Task<SomeObject> Main()
{
    try
    {
        await Task.Run(() =>
        {
            throw new Exception("Caught!");
        });
		return new SomeObject
		{
			Message = "Everything is fine"
		};
    }
    catch (Exception ex)
    {
        Console.WriteLine("Handled it: " + ex.Message);
    }
	 finally
	 {
			Console.WriteLine("Hello");
	 }
    
}

ჩვენ ვიცით რომ Finally ბლოკი ყოველთვის გაეშვება იმის მიუხედავად თუ რა მოხდება Try ში , მაგრამ შეხედეთ Try-ში ჩვენ დაბრუნების ოპერაცია გვაქვს და თუ მეთოდმა დააბრუნა მნიშვნელობა მაშინ ის წაიშლება Thread-ის Call Stack-იდან და მაშინ როგორ ეშვება ეს Finally?

რეალურად ამ თემაზე კომპაილერი ზრუნავს ის დაინახავს თუ არა რომ ჩვენ Try-ში პასუხს ვაბრუნებთ ის ადგება და ამ პასუხს შეინახავს stack frame-ის მეხსიერებაში , შემდეგ შეასრულებს finally ბლოკს და ამის შემდეგ დააბრუნებს მეთოდის პასუხს ამისთვის სჭირდება კომპაილერს ამ საკვანძო სიტყვების ცოდნა.


Runtime-ი კიდე ისეა მოწყობილი რომ გამონაკლისი თუ გავარდა Thread-ის თითოეულ call stack-ზე ეძებს try-catch ბლოკს რომ ეს გამონაკლისი მოგვარდეს.