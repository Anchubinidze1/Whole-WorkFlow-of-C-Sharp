
გამონაკლისების დამუშავება არის CLR-ის კიდევ ერთი სერვისი , რომელიც გვეხმარება ისეთი პრობლემების აღმოსაჩენად , რომლებიც ჩნდება კოდის გაშვების შემდეგ ამას Runtime error-ები ეწოდება.

## ისტორია

სანამ პროგრამებში გამონაკლისების დამუშავება გვექნებოდა ერორების დამუშავება ხდებოდა მექანიკურად . ეს ხდებოდა ერორის კოდების გამოყენებით (მაგალითად : -1 , NULL) , ასევე გამოყენებული იყო `goto` განცხადებები ,  რომლებიც გადახტებოდნენ ასაწმენდ კოდზე შეცდომისას.
ასევე სტატუსის ფლეგებიც იყო გამოყენებული (მაგ : `errno` C-ში).

ჯამში ვიღებდით რაღაც ასეთ კოდს

`int result = doWork();`
if (result == -1) {
    // შემოწმდება ერორები
    // შეინახება ამ ერორის ჩანაწერები
    // რესურსის გამსუფთავებელი
    return -1; // შესაბამისის ერორის კოდის დაბრუნება
}

კოდი რაც უფრო იზრდებოდა მით უფრო რთული იყო ამ სტრუტურის გამოყენება და შენარჩუნება.


შემდეგ პირველად LISP-ში გვხდება სტრუქტურული გამონაკლისების დამუშავების სტრუქტურა ,სადაც შედარებით უკდეთესი ერორების სიგნალის და დამუშავების ხერხები გვხდება რადგან იქ განცხადების სისტემა იყო ჩანერგილი , რომლის იდეაც იყო ნორმანული და გამონაკლისთა დამუშავების ლოგიკის განცალკევება.

შემდეგი განვითარების ეტაპი უკვე 1970-1980-იან წლებში იყო სადაც უკვე დღეისთვის ნაცნობი სახე მიიღეს გამონაკლისების დამმუშავებლებმა მაგალითად : Ada დაპროგრამების ენაში გვხდება პირველი რეალური try-catch მოდელი , რომელიც ენის ნაწილი იყო. C++ ში უკვე გვხდება try , catch , throw საკვანძო სიტყვები რომლებიც გამონაკლისების დამუშავებისთვის არის შექმნილი .  ასევე დაამატა Stack unwinding , destructors და type-based dispatch-ი.


- **Stack unwinding** - არის პროცესი , რომელიც ხდება გამონაკლისთა დამუშავებისას . გამონაკლისის პოვნისას Runtime-ი ცდილობს Thread-ის Call stack-ში Try-Catch-ის ბლოკის პოვნას თუ ვერ იპოვა შესაბამისი Catch ბლოკი მაშინ პროგრამა დაიქრაშება

1995 წელს უკვე ჯავამ შემოიტანა შემოწმებული გამონაკლისების ცნება , სადაც დეველოპერებს უწევთად მიეთითებიათ თუ რა სახის გამონაკლისი შეიძლება გამოეწვია კონკრეტულ მეთოდს. 

მოგვიანებით .NET-ისა და CLR-ის შექმნისას , იმისათვის რომ გაეუმჯობესებიათ გამონაკლისების მოგვარების პრობლემა გააერთიანეს C++/Java .


## Exception Handling and Task Class

როდესაც გამონაკლისების მოგვარებას განვიხიხლავდი ძალიან დამაინტერესა ერთმა შეკითხვამ . ვთქვათ გვაქვს ასეთი შემთხვევა


`static async Task Main()`
{
    try
    {
        `await Task.Run(() =>`
        {
            throw new Exception("Caught!");
        });
    }
    catch (Exception ex)
    {
        `Console.WriteLine("Handled it: " + ex.Message);`
    }

    Console.WriteLine("This line *will* run.");
}


ცალკეულ Thread-ზე ვუშვებთ მეთოდს რომელიც ისვრის გამონაკლისს , როგორ ხდება რომ Thread-ი ერთიდან მეორეში აძლევს ამ გამონაკლისს , მე წინა თავებში უკვე აღწერე რომ Thread-ებს შორის ინფორმაციის გაცვლა არც თუ ისე მარტივი ოპერაციაა ის ოპერაციული სისტემისგან არის შეზღუდული. როგორც ჩანს ამას თვითონ Task კლასი აგვარებს თუ Runtime-მა დაინახა რომ გამონაკლისის დაჭერა ვერ მოხერხდა ამ Thread-ზე მაშინ ის მას გადასცემს იმ Thread-ს რომელიც იძახებს ამ გამონაკლისის მსროლელ მეთოდს. და იქ ცდის მის მოგვარებას .

ზოგადად try/catch- არის შექმნილი კომპაილერისა და Runtime-ისთვის , რომ ეს კოდის ბლოკი ისე დაამუშაონ რომ გამონაკლისის დაჭერა მოხდეს .

მაგალითად ვართ მეთოდში :

`static async Task<SomeObject> Main()`
{
    try
    {
        `await Task.Run(() =>`
        {
            throw new Exception("Caught!");
        });
		`return new SomeObject`
		{
			Message = "Everything is fine"
		};
    }
    catch (Exception ex)
    {
        Console.WriteLine("Handled it: " + ex.Message);
    }
	 finally
	 {
			`Console.WriteLine("Hello");`
	 }
    
}

ჩვენ ვიცით რომ Finally ბლოკი ყოველთვის გაეშვება იმის მიუხედავად თუ რა მოხდება Try ში , მაგრამ შეხედეთ Try-ში ჩვენ დაბრუნების ოპერაცია გვაქვს და თუ მეთოდმა დააბრუნა მნიშვნელობა მაშინ ის წაიშლება Thread-ის Call Stack-იდან და მაშინ როგორ ეშვება ეს Finally?

რეალურად ამ თემაზე კომპაილერი ზრუნავს ის დაინახავს თუ არა რომ ჩვენ Try-ში პასუხს ვაბრუნებთ ის ადგება და ამ პასუხს შეინახავს stack frame-ის მეხსიერებაში , შემდეგ შეასრულებს finally ბლოკს და ამის შემდეგ დააბრუნებს მეთოდის პასუხს ამისთვის სჭირდება კომპაილერს ამ საკვანძო სიტყვების ცოდნა.


Runtime-ი კიდე ისეა მოწყობილი რომ გამონაკლისი თუ გავარდა Thread-ის თითოეულ call stack-ზე ეძებს try-catch ბლოკს რომ ეს გამონაკლისი მოგვარდეს

## Exception handling and CLR

ჩვენ ნაწილობრივ შევეხეთ გამონაკლისების მოგვარების პროცესს CLR-ში , მაგრამ ამ ნაწილში მას ვრცლად განვიხილავ. რეალურად გამონაკლისების მოგვარების პროცესი რამოდენიმე ეტაპისგან შედგება . მისი მთავარი მიზანია კოდის "დაქრაშვის" ნაცვლად გამონაკლისის გააზრება , დამუშავება და პროგრამის მართულად დასრულება ან გაგრძელება.

რა არის გამონაკლისი CLR-ისთვის?

CLR-ში გამონაკლისი არის ობიექტი , რომელიც აღწერს , რომ რაღაც არასწორი მოხდა პროგრამის შესრულებისას.  ეს ობიექტი ჩვეულებრივ არის `System.Exception`-ის ან მისი შვილობილი კლასის ინსთანსი. 

როდესაც რაიმე არასწორი ხდება მაგალითად ,  არასწორი ინდექსით სიაში წვდომა ან გაყოფა ნულზე მაშინ CLR-ი აგენერირებს გამონაკლისის ობიექტს და იწყებს მის დამუშავებას.

ეს დამუშავება შედგება ორი ფაზისგან ესენია 

- ძიების ფაზა (Search Phase) - სადაც CLR გამონაკლისის გავარდნის ადგილიდან ზედიზედ გადადიდს Thread-ში არსებულ Call Stack-ზე და ეძებს ისეთი კოდის ბლოკს რომელიც გამონაკის შეესაბამებეა - მაგალითად : Catch (`IOException`) ან catch(Exception)  . თუ ვერ მოხდა შეცდომის დამუშავება მაშინ . თუ ამ ფაზაში ვერ მოიძებნა შესაბამისი Catch-ბლოკი მაშინ პროგრამა იქნება unhandled და კონსოლ აპლიკაციის შემთხვევაში ის იქრაშება.
- Stack -ის გაწმენდის ფაზა (Unwind Phase) - როდესაც შესაბამისი Catch ბლოკი მოიძებნება , CLR იწყებს Stack-ის გაწმენდას , ანუ ათავისუფლებს იმ რესურსებს რომელიც მასზეა მინიჭებული. ამ ფუნქციას Unwind ქვია იმიტომ რომ ნაბიჯ-ნაბიჯ ტოვებს ყველა იმ ფუნქციას , რომელიც გამოიძახა იმ კოდსი გამოძახებამდე სადაც გამონაკლისი მოხდა

## კომპაილერი და  გამონაკლისები

კომპაილერის დონეზე გამონაკლისები ინახება სპეციალურ გამონაკლისების ცხრილში , რომელიც გამონაკლისების შესახემ ინფომრაციას შეიცავს . შესაძლოა ივარაუდოთ რომ ეს გამონაკლისები მეტადატაში ინახება მაგრამ ეს ასე არ არის ის ინახება IL კოდთან ერთად მეთოდის სხეულში.

IL-ი მეთოდს აფორმატირებს ორ სახეობად ეს არის :
- პატარა ფორმატი - გამოიყენება ძალიან პატარა მეთოდებისთვის (<=64 ბაიტის ზომის IL) და ის მხარს არ უჭერს გამონაკლისების მოგვარებას.
- სქელი ფორმატი - გამოიყენება დიდი ზომის მეთოდებისთვის და ის მხარს უჭერს ცვლადებს , გამონაკლისებს და ასე შემდეგ.


მეთოდის IL ის დინებას მოყვება ეს გამონაკლისების ცხრილიც და ის იყოფა Exception Handling (EH) Clauses-ებად

თითოუელი Clause-ი შეიცავს 
- Flags - როგორი ტიპის პუნქტია მისი მანიშნებელია ეს შესაძლებელია იყოს : catch , filter , finally , fault).
- `TryOffset` - არის Try ბლოკის დაწყების მანიშნებელი IL-ში.
- `TryLenght` - არის Try ბლოკის სიგრძე.
- `HandlerOffset` - catch/finally ბლოკის დასაწყისის მანიშნებელი
- `HandlerLength` - catch/finally ბლოკის სიგრძის მანიშნებელი
- `ClassToken` - catch-ის ტიპის ტოკენი


**რას შვება უშვება ამ გამონაკლისების ცხრილებს JIT**

როდესაც JIT  მიიღებს გამონაკლისების ცხრილის მქონე IL-ს ის უბრალოდ არ გადააქცევს ამ IL მანქანის კოდად ის ჯერ მას გადათარგმნის Runtime-ის სპეციფიკურ სტრუქტურებად , რომლის გამოყენებაც შეუძლია CLR-ს კოდის მუშაობის დროს.

როდესაც IL გამონაკლისების ცხრილს გამოიძახებს ის შეხედავს მეთოდის ჰედერს და შეამოწმებს EH clauses. ის თითეულ clauses გადაპარსავა და გაიგებს როგორი ტიპისაა ის metadata ტოკენს გაიგებს და მის ზომას.

შემდეეგ JIT გარდაქმნის ამ ცხრილებს , EH აღწერის ცხრილებად , რომელიც შეიცავს :
- დაცული რეგიონის კოდის დასაწყის და დასასრულს (try)
- ჰენდლერი რეგიონის კოდის დასაწყის და დასასრულს (catch)
- ჰენდლერის ტიპს (catch/finally/filter/fault)
- გამონაკლის ტიპის ჰენდელრი (runtime-ის ფოინთერი ,რომელიც System.Type ობიექტს უყურებს დაჭერილი ტიპის)
- შესაძლოა ნაგვის ამგროვებელზეც იყოს რაიმე ინფორმაციას Stack unwidning-ს თუ დასჭირდა.