C# ში ტერმინოლოგია Thread Manager - ასე არ გვხდება , მაგრამ მისი იდეა არის ჩადებული CLR -ში . აქ მათ Threading System-ს ან მარტივად Threading-ს ეძახიან მაგრამ მათი პასუხისმგებლობა საერთოა : Thread Pool ,  Task Scheduler , CLR Thread Management .

სანამ ამ მაღალი დონის რაღაცეებს განვიხილავ ჯობია რომ ფუნდიმენტალები განვმარტო.


Thread - არის შესრულების ყველაზე მცირე ერთეული , რომლის შესრულება პროცესორს შეუძლია , ანუ ბრძანებების თანმიმდევრობის უმცირესი რაოდენობა რაც პროცესორს ესაჭიროება შესასრულებლად.

ყველა პროცესი იწყება ერთი მთავარი Thread-ით , ამის შემდეგ დამატებით Thread-ებს ქმნის დეველოპერი ან პროგრამა საჭიროებიდან გამომდინარე.


### ისტორია ###

ძველ კომპიუტერებში (1940-1960) ერთდროულად მხოლოდ ერთი პროგრამის გაშვება იყო შესაძლებელი და კომპოუტერის მთელი რესურსი (CPU, Memory) იყო მიმართული ამ ერთი პროგრამის მუშოაბაზე .

შემდგომ პერიოდში გამოიგონეს მულტიპროგრამირება (Multiprogramming 1960-1970 ) - სადაც უკვე რამოდეინმე პროგრამის ჩატვირთვა შეგვეძლო მეხსიერებაში.
CPU- ერთი პროგრამიდან მეორეზე გადადიოდა რამაც მოგვცა პარალელურობის ილუზია. 

ამ დროს შემოვიდა პროცესებიც - პროცესი არის მეხსიერებაში პროგრამისთვის გამოყოფილი თავის გარემო , რომელსაც გააჩნია თავის მეხსიერება და რესურსები და ისინი სრულიად იზოლირებულნი არიან ერთმანეთისგან. 

ეს პროცესები თავის საქმეს აკეთებდა მაგრამ თავის პრობლემები ჰქონდა , მაგალითად:  პროცესები შექმნა ან ერთიდან მეორეში გადასხვლა ძვირადღირებული პროცესია , რაგან თითოეულ მათგანს თავის მეხსიერების , რესურსებისა და იზოლაციის კონტროლი უწევს , გვჭირდებოდა რაღაც ისეთი რაც ამ პრობლემას გამოასწრორებდა.

ამისთვის გამოიგონეს Thead-ები , რომლებსაც მსუბუქ პროცესებსაც კი უწოდებდნენ , პროცესში გვაქვს მინიმუმ ერთი Thread-ი მაინც , ზოგადად რამოდენიმე Thread-ი იზიარებს ერთმანეთში იმფორმაციას და რესურსებს , თითოეულ Thread-ს გააჩნია თავის Call stack - ანუ რომელი მეთოდი იქნა პირველი გამოძახებული , ასევე თითოეული გამოძახებული მეთოდს გამოეყოფა თავის Stack frame , რომელიც შეიცავს მეთოდზე არსებულ მთლიან ინფორმაციას , Stack frame layout - არის Stack frame ის სტრუქტურის აღწერა მე ამ თემას უკვე შევეხე GC ის მუშაობის პროცესის აღწერისას.

ამის შემდეგ დაიწყო Thread-ების მანიპულაცია დაპროგრამების ენებში  , ცნობილ მათგანს ჩამოვთლი
- C , C++ - იყენებდა `pthreads` , `Windows Threads` და ასე შემდეგ.
- Java(1995) - ჯავამ უკვე მაღალი დონის ენებში შემოიტანა Thread-ების გამოყენება Thread კლასის შემოტანითა და multithreading API-ის გამოყენებით.
- .NET Framework(2002) - CLR-მა შემოიტანა Managed Thread-ები (`System.Threading.Thread`) , thread pool და მოგვიანებით Task და `async/await` მაღალი დონის concurrency-ის მისაღებად.


**რატომ უჭერს მხარს ვინდოუსი Thread-ებს**

ძველი კომპიუტერების დროს არ არსებობდა Thread-ების ცნება და არსებობდა შესრულების მხოლოდ ერთი ხაზი , პრობლემა ის იყო რომ ხანგძლივი დავალების გაკეთების დროს სხვა დავალებები ვერ შესრულდებოდა. მაგალითად 16-ბიტიანი ვინდოუსის დროს ერთ-ერთი ყველაზე ხშირად გამოყენებული აპლიკაცია იყო დოკუმენტის დაპრინტერება , რომელიც კომპიუტერში სხვა ყველა პროცესს აჩერებდა , ზოგჯელ საერთოდ ბაგი ქონდა ზოგ აპლიკაციას და სისტემას უსასრულო ციკლში კეტავდა. მაიქროსოფთმა იცოდა რომ 16-ბიტიანი ვინდოუსით შორს ვერ წავიდოდნენ და გადაწყვიტეს შეექმნათ ახალი ოპერაციული სისტემა Windows NT kernel. 

Windows NT Kernel - ის შექმნის დროს მაიქროსოფთში გადაწყვიტეს რომ აპლიკაციის თითოეული ინსთანსი გაეშვათ პროცესში. პროცესი როგორც აღვწერე არის იმ რესურსების კომბინაცია , რომელიც ესაჭიროება ამ აპლიკაციის ინსთანს გასაშვებად. თითოეულ პროცეს თავის ვირტუალური მისამართი აქვს რისი დახმარებით პროცესში გამოყენებულ რესურსზე წვდომა მხოლოდ ამ პროცესს შეუძლია , ასევე ოპერაციული სისტემის კოდს არანაირი კავშირი არ აქვს პროცესში არსებულ კოდთან , რაც დაცვის მექანიზმია იმის რომ აპლიკაციის კოდმა ვერ შეძლოს ოპერაციული სისტემის კოდსი გაფუჭება . რეალურად ოპერაციული სისტემის კოდი მუშაობს Kernel ის რეჟიმზე ზოგჯელ მას ring 0-საც ეძახიან , ხოლო აპლიკაციის კოდი არის გაშვებული მომხმარებლის რეჟიმზე . Kernel-ის რეჟიმს ბევრად მეტი პრივილეგია აქვს ვიდერე მომხმარებლის რეჟიმს. 

ეს ყველაფერი კარგია OS-ის დონეზე მაგრამ რა ხდება პროცესორში? რა მოუვა პროცესორს თუ აპლიკაცია უსასრულო ციკლზე გავა?

თუ მოწყობილობას ერთი პროცესორი აქვს მაშინ ის უსასრულო ციკლში იქნება გაჭედილი და სხვა ვერაფერს გააკეთებს , მართალია სხვა პროცესებში არსებული მონაცემები ვერ აირევა მაგრამ ისინი ვერ შესრულდებიან. მაიქროსოფთმა ამის საპასუხოდ შემოიღო Thread-ები , რომლებიც პროცესორის ვირტუალიზებას აკეთებდნენ , თითოეულ პროცესს თავი Thread-ი ქონდა მინიჭებული და თუ ის უსასრულო ციკლში შევიდოდა ამ Thread-თან დაკავშირებული პროცესი გაიყინებოდა , მაგრამ სხვა პროცესები გააგრძელებდნენ მუშაობას


### Thead-ის ზედნადებები 

ვინდოუსის სისტემაში ყველა Thread-ს აქვს შემდეგი ზედნადებები:

- Thread kernel object - არის ობიექტი , რომლისთვისაც მეხისერებას გამოყოფს ოპერაციული სისტემა. ამ ობიექტში შევხდებით მრავალ თვისებებს , რომლებიც აღწეერნ თვითონ Thread-ს (ამ თვისებებს მოგვიანებით ჩავუღრმავდები). ამ ობიექტში ჩვენ ასევე გვხდება Thread-ის კონტექტსი - კონტექსტი ამ Thread-ში გულისხმობს იმ მეხსიერების ბლოკს , რომელიც შეიცავს CPU-ს რეგისტრების ნაკრებს, თითოეული პროცესორის ტიპისთვის ეს კონტექსტი განსხვავებული ზომისაა.
- Thread environment block (TEB) -  არის მომხმარებლის რეჟიმში გამოყოფილი მეხსიერება ( ეს არის მისამართის ადგილი რომელსაც აპლიკაციის კოდს მარტივად შეიძლება მიწვდეს). მისი ზომა არის 1 გვერდის ტოლი (x86 , x64 და ARM-ის არქიტექტურებში ეს 4KB ნიშნავს). ის მოიცავს Thread-ში არსებული Exception Handling -ის ჯაჭვის თავს . აპლიაციაში თითოეული Thread-ში არსებული Try block ამატებს ამ ჯაჭვს ახალ ტოტს . ეს ტოტი იშლება Try block იდან გამოსხვლის დროს . TEB ასევე ინახავს Thread-ის ლოკალური მონაცემების საცავს , ზოგიერთ მონაცემთა სტრუქტურას , გრაფიკული დიზაინის ინტერფეისებს და სხვა ბევრ რამეს რასაც არ ჩავუღრმავდები.
- User-mode stack - ყოველ მომხმარებლის რეჟიმზე გაშვებულ Thread-ს აქვს თავისი მეხსიერება Stack-ისთვის. ის გამოიყენება ლოკალურ ცვლადებსა , მეთოდებში არგუმენტების გადასაცემად და იმ მისამართების შესანახად რაზეც პროგრამა უნდა გადაციდეს მეთოდის შესრულების შემდეგ , ვინდოუსში ყველა Threads-ს აქვს თავისი user-mode stack და მათი ზომა ნაგულისხმევად არის 1MB.
- Kerner-mode stack - ყოველ Thread-ს მეხსიერებაში ასევე გამოეყოფა  Kerner-mode stack , ის აქტიურდება როდესაც აპლიკაციი კოდი ცდილობს არგუმენტების გადაცემას Kerner-ის დონის მეთოდზე . ამ დროს ვინდოუსი დააკოპირებს არგუმენტებს და ჩასვავს მას Kerner-mode stack -ში დაცვის მიზნით სადაც მათი ვალიდაცია ხდება და შემდეგ ოპერაციული სისტემის კოდის ეშვება მასზე . ნაგულისხმევად მათი ზომა 32-ბიტიან ვინდოუსზე არის 12KB , ხოლო 64-ბიტიანზე არის 24KB.
- DLL thread-attach and thread-detach notifications - ვინდოუსს აქვს ისეთი პოლიტიკა რომ ყოველი Thread-ის შექმნისას ყველა Unmanaged DLL-ების ჩამტვირთავს ამ პროცესში გამოეძახებათ თავიანთი DLL-Main მეთოდი და გადეცემათ DLL_THREAD_ATTACH flag . ანალოგიური ხდება Thread-ის სიკვდილის შემდეგაც უბრალოდ აქ არგუმენტად DLL_THREAD_DETACH flag გადაეცემა. ზოგიერთ DLL-ს სჭირდება ეს შეტყობინებები იმისათვის რომ რაღაცად დამატებითი ინიცილიზება ან გაწმენდის ოპერაცია ჩაატაროს Thrad-ის შემქნა/განადგურების შედეგად.


ზემოთ აღწერილი Call Stack , Stack Frame , Stack Frame Layout ფიზიკურად მდებარეობენ User-mode stack-ზე ან სიტვაციურად  Kerner-mode stack-ზე.

          +-----------------------+
          |   Thread Kernel Object|   <--- In Kernel memory (used by OS)
          +-----------------------+
                   |
                   v
+---------------------------------------------+
|    Process Virtual Address Space                |
|                                                                    |
|             +---------------------+                   |
|              | Thread Environment  |                 |
|              | Block (TEB)                 |    <--- In User memory (used by OS, runtime, some libs)
|             +---------------------+                   |
|                               |                                   |
|                               v                                   |
|             +-----------------------+                |
|             |   User-mode Stack     |     <--- In User memory, private to thread
|             +-----------------------+                 |
|             |   |   -- Call Stack --       |  |                |
|             |   |         +----------+     |  |                 |
|             |   |          | Stack        |    |  |                 |
|             |   |          | Frame(s)   |    |  |  <--- Each function call adds a stack frame
|             |   |          +----------+    |  |
|             |   |        (Stack Frame     |  |
|             |   |       Layouts define   |  |
|             |   |       how each           |  |
|             |   |      frame looks)       |  |
|                +-----------------------+                 |
|                                                                        |
|   +-----------------------+                              |
|   | Kernel-mode Stack     |   <--- In Kernel memory, private to thread/OS
|   +-----------------------+                                |
+---------------------------------------------+

ომპიუტერში, როგორც წესი, გვაქვს ერთი პროცესორი, ხოლო თანამედროვე პროცესორებში ამ ერთ პროცესორში რამდენიმე ბირთვი (ფიზიკური ბირთვი) არის ჩამონტაჟებული. თუ პროცესორი მხარს უჭერს Hyper-Threading-ს ან SMT (Simultaneous Multi-Threading) ტექნოლოგიებს, მაშინ თითოეული ფიზიკური ბირთვი იყოფა ორ (ან მეტ) ვირტუალურ (ლოგიკურ) ბირთვად.

როდესაც ოპერაციულ სისტემა ან პროგრამა უშვებს თრედებს ვირტუალურ ბირთვებზე, მათი ბრძანებები მიდის იმავე ფიზიკურ ბირთვში, რომელიც თავის რესურსებს უნაწილებს სხვადასხვა ვირტუალურ ბირთვს (ანუ ამ თრედებს). ვირტუალური ბირთვი მოცემულ მომენტში ასრულებს მხოლოდ ერთ Thread-ს, თუმცა ფიზიკური ბირთვი ერთდროულად რამდენიმე ვირტუალური ბირთვის (ანუ რამდენიმე Thread-ის) შესრულებას უზრუნველყოფს.

ვირტუალური ბირთვებიდან ინფორმაციული ნაკადები პარალელურად შედის ფიზიკურ ბირთვში, ხოლო საბოლოო შესრულება და რესურსების განაწილება ხდება ფიზიკურ დონეზე.


როცა პროცესორზე თრედების რაოდენობა უფრო მეტია, ვიდრე ბირთვების რაოდენობა, ყველა თრედს არ შეუძლია ერთდროულად მუშაობა. ამიტომ ოპერაციული სისტემა ანაწილებს „დროის ნაჭრებს“ (time-slice, ან quantum) თითოეულ თრედზე.

**time-slice (ასევე quantum)** — ეს არის მცირე დროის ინტერვალი, რომლის განმავლობაშიც ოპერაციული სისტემა აძლევს Thread-ს ბირთვთან მუშაობის შესაძლებლობას.  
Time-slice-ს აკონტროლებს და არიგებს ოპერაციული სისტემა (მაგალითად, Windows).

როდესაც ერთი Thread იდან მეორეზე გადადის ბირთვი ამას ქვია უკვე Context Switching-ი.

არ რამოდენიმე დეტალია გასათვალისწინებელი , მაგალითად სად მახსოვრდება წინა Thread-თან მუშაობის ინფორმაცია და როგორ არის ის დაცული სხვა Thread-ის ინფორმაციის შერევისგან.

პროცესორი ინახავს მიმდინარე Thread-ის მდგომარეობას (რეგისტრებში , სტეკში და ა.შ.) , შემდეგ ჩაიტვირთება სხვა Thread-ის მდგომარეობა და ასეთი გადაცვლა გადმოცვლა ხდება იმ შემთხევაში თუ უფრო მეტი Thread-ია ვიდრე ბირთვი.



