C# ში ტერმინოლოგია Thread Manager - ასე არ გვხდება , მაგრამ მისი იდეა არის ჩადებული CLR -ში . აქ მათ Threading System-ს ან მარტივად Threading-ს ეძახიან მაგრამ მათი პასუხისმგებლობა საერთოა : Thread Pool ,  Task Scheduler , CLR Thread Management .

სანამ ამ მაღალი დონის რაღაცეებს განვიხილავ ჯობია რომ ფუნდიმენტალები განვმარტო.


Thread - არის შესრულების ყველაზე მცირე ერთეული , რომლის შესრულება პროცესორს შეუძლია , ანუ ბრძანებების თანმიმდევრობის უმცირესი რაოდენობა რაც პროცესორს ესაჭიროება შესასრულებლად.

ყველა პროცესი იწყება ერთი მთავარი Thread-ით , ამის შემდეგ დამატებით Thread-ებს ქმნის დეველოპერი ან პროგრამა საჭიროებიდან გამომდინარე.


### ისტორია ###

ძველ კომპიუტერებში (1940-1960) ერთდროულად მხოლოდ ერთი პროგრამის გაშვება იყო შესაძლებელი და კომპოუტერის მთელი რესურსი (CPU, Memory) იყო მიმართული ამ ერთი პროგრამის მუშოაბაზე .

შემდგომ პერიოდში გამოიგონეს მულტიპროგრამირება (Multiprogramming 1960-1970 ) - სადაც უკვე რამოდეინმე პროგრამის ჩატვირთვა შეგვეძლო მეხსიერებაში.
CPU- ერთი პროგრამიდან მეორეზე გადადიოდა რამაც მოგვცა პარალელურობის ილუზია. 

ამ დროს შემოვიდა პროცესებიც - პროცესი არის მეხსიერებაში პროგრამისთვის გამოყოფილი თავის გარემო , რომელსაც გააჩნია თავის მეხსიერება და რესურსები და ისინი სრულიად იზოლირებულნი არიან ერთმანეთისგან. 

ეს პროცესები თავის საქმეს აკეთებდნენ მაგრამ თავის პრობლემები ჰქონდათ , მაგალითად:  პროცესები შექმნა ან ერთიდან მეორეში გადასვლა ძვირადღირებული პროცედურაა , რაგან თითოეულ მათგანს თავის მეხსიერების , რესურსებისა და იზოლაციის კონტროლი უწევს . გვჭირდებოდა რაღაც ისეთი რაც ამ პრობლემას გადაჭრიდა.

ამისთვის გამოიგონეს Thead-ები , რომლებსაც მსუბუქ პროცესებსაც კი უწოდებდნენ , პროცესში გვაქვს მინიმუმ ერთი Thread-ი მაინც , ზოგადად რამოდენიმე Thread-ი იზიარებს ერთმანეთში იმფორმაციას და რესურსებს , თითოეულ Thread-ს გააჩნია თავის Call stack - ანუ რომელი მეთოდი იქნა პირველი გამოძახებული , ასევე თითოეული გამოძახებული მეთოდს გამოეყოფა თავის Stack frame , რომელიც შეიცავს მეთოდზე არსებულ მთლიან ინფორმაციას , Stack frame layout - არის Stack frame ის სტრუქტურის აღწერა მე ამ თემას უკვე შევეხე GC ის მუშაობის პროცესის აღწერისას.

ამის შემდეგ დაიწყო Thread-ების მანიპულაცია დაპროგრამების ენებში  , ცნობილ მათგანს ჩამოვთლი
- C , C++ - იყენებდა `pthreads` , `Windows Threads` და ასე შემდეგ.
- Java(1995) - ჯავამ უკვე მაღალი დონის ენებში შემოიტანა Thread-ების გამოყენება Thread კლასის შემოტანითა და multithreading API-ის გამოყენებით.
- .NET Framework(2002) - CLR-მა შემოიტანა Managed Thread-ები (`System.Threading.Thread`) , thread pool და მოგვიანებით Task და `async/await` მაღალი დონის concurrency-ის მისაღებად.


**რატომ უჭერს მხარს ვინდოუსი Thread-ებს**

ძველი კომპიუტერების დროს არ არსებობდა Thread-ების ცნება და არსებობდა შესრულების მხოლოდ ერთი ხაზი , პრობლემა ის იყო რომ ხანგძლივი დავალების გაკეთების დროს სხვა დავალებები ვერ შესრულდებოდა. მაგალითად 16-ბიტიანი ვინდოუსის დროს ერთ-ერთი ყველაზე ხშირად გამოყენებული აპლიკაცია იყო დოკუმენტის დაპრინტერება , რომელიც კომპიუტერში სხვა ყველა პროცესს აჩერებდა , ზოგჯელ საერთოდ ბაგი ქონდა ზოგ აპლიკაციას და სისტემას უსასრულო ციკლში კეტავდა. მაიქროსოფთმა იცოდა რომ 16-ბიტიანი ვინდოუსით შორს ვერ წავიდოდნენ და გადაწყვიტეს შეექმნათ ახალი ოპერაციული სისტემა Windows NT kernel. 

Windows NT Kernel - ის შექმნის დროს მაიქროსოფთში გადაწყვიტეს რომ აპლიკაციის თითოეული ინსთანსი გაეშვათ პროცესში. პროცესი როგორც აღვწერე არის იმ რესურსების კომბინაცია , რომელიც ესაჭიროება ამ აპლიკაციის ინსთანს გასაშვებად. თითოეულ პროცეს თავის ვირტუალური მისამართი აქვს რისი დახმარებით პროცესში გამოყენებულ რესურსზე წვდომა მხოლოდ ამ პროცესს შეუძლია , ასევე ოპერაციული სისტემის კოდს არანაირი კავშირი არ აქვს პროცესში არსებულ კოდთან , რაც დაცვის მექანიზმია იმის რომ აპლიკაციის კოდმა ვერ შეძლოს ოპერაციული სისტემის კოდსი გაფუჭება . 

რეალურად ოპერაციული სისტემის კოდი მუშაობს Kernel ის რეჟიმზე ზოგჯელ მას ring 0-საც ეძახიან , ხოლო აპლიკაციის კოდი არის გაშვებული მომხმარებლის რეჟიმზე . Kernel-ის რეჟიმს ბევრად მეტი პრივილეგია აქვს ვიდერე მომხმარებლის რეჟიმს. 

ეს ყველაფერი კარგია OS-ის დონეზე მაგრამ რა ხდება პროცესორში? რა მოუვა პროცესორს თუ აპლიკაცია უსასრულო ციკლზე გავა?

თუ მოწყობილობას ერთი პროცესორი აქვს მაშინ ის უსასრულო ციკლში იქნება გაჭედილი და სხვა ვერაფერს გააკეთებს , მართალია სხვა პროცესებში არსებული მონაცემები ვერ აირევა მაგრამ ისინი ვერ შესრულდებიან. მაიქროსოფთმა ამის საპასუხოდ შემოიღო Thread-ები , რომლებიც პროცესორის ვირტუალიზებას აკეთებდნენ , თითოეულ პროცესს თავი Thread-ი ქონდა მინიჭებული და თუ ის უსასრულო ციკლში შევიდოდა ამ Thread-თან დაკავშირებული პროცესი გაიყინებოდა , მაგრამ სხვა პროცესები გააგრძელებდნენ მუშაობას


### Thead-ის ზედნადებები 

ვინდოუსის სისტემაში ყველა Thread-ს აქვს შემდეგი ზედნადებები:

- Thread kernel object - არის ობიექტი , რომლისთვისაც მეხისერებას გამოყოფს ოპერაციული სისტემა. ამ ობიექტში შევხდებით მრავალ თვისებებს , რომლებიც აღწეერნ თვითონ Thread-ს (ამ თვისებებს მოგვიანებით ჩავუღრმავდები). ამ ობიექტში ჩვენ ასევე გვხდება Thread-ის კონტექტსი - კონტექსტი ამ Thread-ში გულისხმობს იმ მეხსიერების ბლოკს , რომელიც შეიცავს CPU-ს რეგისტრების ნაკრებს, თითოეული პროცესორის ტიპისთვის ეს კონტექსტი განსხვავებული ზომისაა.
- Thread environment block (TEB) -  არის მომხმარებლის რეჟიმში გამოყოფილი მეხსიერება ( ეს არის მისამართის ადგილი რომელსაც აპლიკაციის კოდს მარტივად შეიძლება მიწვდეს). მისი ზომა არის 1 გვერდის ტოლი (x86 , x64 და ARM-ის არქიტექტურებში ეს 4KB ნიშნავს). ის მოიცავს Thread-ში არსებული Exception Handling -ის ჯაჭვის თავს . აპლიაციაში თითოეული Thread-ში არსებული Try block ამატებს ამ ჯაჭვს ახალ ტოტს . ეს ტოტი იშლება Try block იდან გამოსხვლის დროს . TEB ასევე ინახავს Thread-ის ლოკალური მონაცემების საცავს , ზოგიერთ მონაცემთა სტრუქტურას , გრაფიკული დიზაინის ინტერფეისებს და სხვა ბევრ რამეს რასაც არ ჩავუღრმავდები.
- User-mode stack - ყოველ მომხმარებლის რეჟიმზე გაშვებულ Thread-ს აქვს თავისი მეხსიერება Stack-ისთვის. ის გამოიყენება ლოკალურ ცვლადებსა , მეთოდებში არგუმენტების გადასაცემად და იმ მისამართების შესანახად რაზეც პროგრამა უნდა გადაციდეს მეთოდის შესრულების შემდეგ , ვინდოუსში ყველა Threads-ს აქვს თავისი user-mode stack და მათი ზომა ნაგულისხმევად არის 1MB.
- Kerner-mode stack - ყოველ Thread-ს მეხსიერებაში ასევე გამოეყოფა  Kerner-mode stack , ის აქტიურდება როდესაც აპლიკაციი კოდი ცდილობს არგუმენტების გადაცემას Kerner-ის დონის მეთოდზე . ამ დროს ვინდოუსი დააკოპირებს არგუმენტებს და ჩასვავს მას Kerner-mode stack -ში დაცვის მიზნით სადაც მათი ვალიდაცია ხდება და შემდეგ ოპერაციული სისტემის კოდის ეშვება მასზე . ნაგულისხმევად მათი ზომა 32-ბიტიან ვინდოუსზე არის 12KB , ხოლო 64-ბიტიანზე არის 24KB.
- DLL thread-attach and thread-detach notifications - ვინდოუსს აქვს ისეთი პოლიტიკა რომ ყოველი Thread-ის შექმნისას ყველა Unmanaged DLL-ების ჩამტვირთავს ამ პროცესში გამოეძახებათ თავიანთი DLL-Main მეთოდი და გადეცემათ DLL_THREAD_ATTACH flag . ანალოგიური ხდება Thread-ის სიკვდილის შემდეგაც უბრალოდ აქ არგუმენტად DLL_THREAD_DETACH flag გადაეცემა. ზოგიერთ DLL-ს სჭირდება ეს შეტყობინებები იმისათვის რომ რაღაცად დამატებითი ინიცილიზება ან გაწმენდის ოპერაცია ჩაატაროს Thrad-ის შემქნა/განადგურების შედეგად.


ზემოთ აღწერილი Call Stack , Stack Frame , Stack Frame Layout ფიზიკურად მდებარეობენ User-mode stack-ზე ან სიტვაციურად  Kerner-mode stack-ზე.

          +-----------------------+
          |   Thread Kernel Object|   <--- In Kernel memory (used by OS)
          +-----------------------+
                   |
                   v
+---------------------------------------------+
|    Process Virtual Address Space                |
|                                                                    |
|             +---------------------+                   |
|              | Thread Environment  |                 |
|              | Block (TEB)                 |    <--- In User memory (used by OS, runtime,  some libs)
|             +---------------------+                   |
|                               |                                   |
|                               v                                   |
|             +-----------------------+                |
|             |   User-mode Stack     |     <--- In User memory, private to thread
|             +-----------------------+                 |
|             |   |   -- Call Stack --       |  |                |
|             |   |         +----------+     |  |                 |
|             |   |          | Stack        |    |  |                 |
|             |   |          | Frame(s)   |    |  |  <--- Each function call adds a stack frame
|             |   |          +----------+    |  |
|             |   |        (Stack Frame     |  |
|             |   |       Layouts define   |  |
|             |   |       how each           |  |
|             |   |      frame looks)       |  |
|                +-----------------------+                 |
|                                                                        |
|   +-----------------------+                              |
|   | Kernel-mode Stack     |   <--- In Kernel memory, private to thread/OS
|   +-----------------------+                                |
+---------------------------------------------+

კომპიუტერში, როგორც წესი, გვაქვს ერთი პროცესორი, ხოლო თანამედროვე პროცესორებში ამ ერთ პროცესორში რამოდენიმე ბირთვი (ფიზიკური ბირთვი) არის ჩამონტაჟებული. თუ პროცესორი მხარს უჭერს Hyper-Threading-ს ან SMT (Simultaneous Multi-Threading) ტექნოლოგიებს, მაშინ თითოეული ფიზიკური ბირთვი იყოფა ორ (ან მეტ) ვირტუალურ (ლოგიკურ) ბირთვად.

როდესაც ოპერაციულ სისტემა ან პროგრამა უშვებს თრედებს ვირტუალურ ბირთვებზე, მათი ბრძანებები მიდის იმავე ფიზიკურ ბირთვში, რომელიც თავის რესურსებს უნაწილებს სხვადასხვა ვირტუალურ ბირთვს (ანუ ამ თრედებს). ვირტუალური ბირთვი მოცემულ მომენტში ასრულებს მხოლოდ ერთ Thread-ს, თუმცა ფიზიკური ბირთვი ერთდროულად რამდენიმე ვირტუალური ბირთვის (ანუ რამდენიმე Thread-ის) შესრულებას უზრუნველყოფს.

ვირტუალური ბირთვებიდან ინფორმაციული ნაკადები პარალელურად შედის ფიზიკურ ბირთვში, ხოლო საბოლოო შესრულება და რესურსების განაწილება ხდება ფიზიკურ დონეზე.


როცა პროცესორზე თრედების რაოდენობა უფრო მეტია, ვიდრე ბირთვების რაოდენობა, ყველა თრედს არ შეუძლია ერთდროულად მუშაობა. ამიტომ ოპერაციული სისტემა ანაწილებს „დროის ნაჭრებს“ (time-slice, ან quantum) თითოეულ თრედზე.

**time-slice (ასევე quantum)** — ეს არის მცირე დროის ინტერვალი, რომლის განმავლობაშიც ოპერაციული სისტემა აძლევს Thread-ს ბირთვთან მუშაობის შესაძლებლობას.  
Time-slice-ს აკონტროლებს და არიგებს ოპერაციული სისტემა (მაგალითად, Windows).

როდესაც ერთი Thread იდან მეორეზე გადადის ბირთვი ამას ქვია უკვე Context Switching-ი.

აქ რამოდენიმე დეტალია გასათვალისწინებელი , მაგალითად სად მახსოვრდება წინა Thread-თან მუშაობის ინფორმაცია და როგორ არის ის დაცული სხვა Thread-ის ინფორმაციის შერევისგან.

პროცესორი ინახავს მიმდინარე Thread-ის მდგომარეობას (რეგისტრებში , სტეკში და ა.შ.) , შემდეგ ჩაიტვირთება სხვა Thread-ის მდგომარეობა და ასეთი გადაცვლა გადმოცვლა ხდება იმ შემთხევაში თუ უფრო მეტი Thread-ია ვიდრე ბირთვი.



## CLR Threads და Windows Threads

.NET Framework-ის დროს , CLR-ის გუნდს ეგონა რომ ერთ დღეს CLR-ი საკუთარ ლოგიკურ Thread-ებს გამოუყოფთა მომხმარებელს , მაგრამ ეს ვერ მოხერხდა ვინდოუსის Thread-ებთან დაკავშირების გამო. ეს მცდელობა 2005 წელს ჩაფლავდა და გადაწყვიტეს რომ CLR ის Thread-ები ვინდოუსის იდენტური ყოფილიყო , მაგრამ .NET Framework-ში მაინც გვხდება ამ მცდელობის ნაშთები , მაგალითად`System.Environment` კლასი დახმარებით ჩვენ ვხედავთ `CurrentManagedThreadId`-ის თვისებას , რომელიც აბრუნებს CLR-ის ID-ს Thread-ისთვის . `System.Diagnostics.ProcessThread`-ის კლასიც კი გვაძლევს Thread-ის ID თვისებასთან წვდომას მაგრამ ის Windows-ის Thread-ის აიდის აბრუნებს.

## Thread Class

`System.Threading.Thread` არის ერთ-ერთი ყველაზე ძველი და Thread-ისთვის პრიმიტიული კლასი .NET-ში , რომელიც გვაძლევს პირდაპირ კონტროლს Thread-ის შექმნაზე , გაშვებაზე და ზოგადად მისი სიცოცხლის ციკლის მენეჯმენტზე. 

სანამ ეს კლასი ექნებოდათ დეველოპერებს იქამდე იყენებდნენ ოპერაციული სისტემის დონის Threading API-ებს (Win32 threads, `pthreads`Unix-ში) , რომლებიც პლატფორმაზე იყვნენ დამოკიდებულნი და შეცდომებისკენ იყო მიდრეკილი. 2001 წელს .NET Framework 1.0 -დან Thread კლასი შემოვიდა , რომელიც ოპერაციული სისტემის Thread-ის აბსტრაქცია იყო მაგრამ მათი დაბალი დონის მართვის საშუალებას მაინც გვაძლევდა.

რეალურად ეს კლასი არის ოპერაციული სისტემის დონის Thread-ზე დაშენებული აბსტრაქცია და შიგნით ოპერაციული სისტემის API ები უდევს .

როდესაც ამ კლასის ინსთანს ვქმნით CLR-ი მოთხოვნას აკეთებს ოპერაციული სისტემის Thread-თან API-ების დახმარებით (ვინდოუსზე - Win32 API , Linux/MacOS - POSIX)

Thread კლასის შექმნის რამოდენიმე ვარიანტი არსებობს , პირველი არის ისეთი მეთოდის გადაცემა რომელიც არგუმენტებს არ იღებს და არაფერს აბრუნებს

ზოგადი მაგალითი 

using System;
using `System.Threading`;`

class Program
{
    static void Worker()
    {
        `Console.WriteLine($"Thread {Thread.CurrentThread.ManagedThreadId} is running.");`
    }

    static void Main()
    {
        // Create a new thread
        Thread thread = new Thread(Worker);
        
        // Start the thread
        thread.Start();

        // Wait for the thread to finish (optional)
        thread.Join();

        Console.WriteLine("Main thread exits.");
    }
}

Thread ობიექტით შექმნილ ცვლადს აქვს 4 ძირითადი მეთოდი

- Start() - იწყებს Thread-ის შესრულებას
- Join() - დაბლოკავს გამომძახებელ Thread-ს იქამდე სანამ მომუშავე Thread-ი არ შეწყვეტს მუშაობას.
- Sleep(`int ms`) - დააოაუზებს მოცემულ Thread-ს კონკრეტული დროით.
- Abort() - მოძველებული მეთოდია რომელსაც Thread-ის განადგურება შეეძლო.

Thread ობიექტის შესაქმნელად ასევე შეგვიძლია არგუმენტიანი მეთოდიც გადავცეთ კომსტრუქტორში

Thread thread = new Thread((object data) => 
{
    `Console.WriteLine($"Received: {data}");`
});
`thread.Start("Hello, Thread!");`

ასევე ამ კლასსის ინსთანს თავის თვისებები მოყვება , მათგან ყველაზე გამოსადეგი არის

- `Name` - შეგვიძლია კონკრეტული სახელი მივცეთ Thread-ს.
- `Priority` - შეგვუძლია პრიორიტეტი მივანიჭოდ 0-10 ის ჩათვლის , თუ არ ვიცით რას ვაკეთებთ ამაზე შეხება არც ღირს,
- `IsBackground` -  ინფორმაციას ვიღებთ Thread-ი უკანა ფონის არის თუ არა



## `ThreadPool`

Thread Pool არის პროგრამირების კონსტრუქცია, რომელიც გამოიყენება Thread ჯგუფის ეფექტურად სამართავად და ხელახლა გამოსაყენებლად, Thread-ების მომენტალურად შექმნისა და განადგურების ნაცვლად. ის ხშირად გამოიყენება სერვერულ აპლიკაციებში, პარალელურ დამუშავებასა და გარემოში, სადაც მაღალი შესრულება კრიტიკულად მნიშვნელოვანია.

კლასიკურ Thread-ს პრობლემები ქონდა ესენია :
- Thread-ის შექმნა საკამაოდ ძვირია უფრო კონკრეტულად თითოეულ Thread-ს 1 MB მეხსიერება ეთმობა Stack-ის პლიუს ოპერაციული სისტემის ზედნადებები.
- გაუკონტროლებადი Thread-ის შექმნა რაც იწვებს მაღალი მეხსიერების გამოყენება , გადაჭარბებული Context Switching , წარმადობის ვარდნა , Thread-ის 'შიმშილი' (სიტვაცია როდესაც CPU დროისთვის ძალიან ბევრი Thread-ი იბრძვის0)

ThreadPool-მა ეს პრობლემები გამოასწორა შემდეგ ნაირად
- Thread-ების ხელთავიდან გამოყენება , Thread-ის შექმნის ნაცვლად არსებულს ვიყენებთ ხელთავიდან.
- ჯამური Thread-ების რაოდენობის შეზღუდვა რომელის სისტემას გადატვირთვისგან იცავს
- დინამიური შესწორებების საშუალება , რომელიც გამოყოფს Thread-ს დიდი ზეწოლის დროს სადაც გამოყენებულია კლდეზე ძრომის იგივე "hill-climbing"-ის ალგორითმი.

`ThreadPool`-ს აქვს 5 მთავრი კომპონენტი 
- Task Queue - C#-ში ამ ცნებას ეძახიან Global Work Queue-ს , რომელიც წარმოადგენს რიგს , რომელშიც მოთავსებულია თავისუფალი Thread-ები , რომლებიც ელოდებიან თავიანდ დროს რათა საქმე შეასრულონ.
- Worker Threads - არიან მომუშავე Thread-ები , რომლებიც საქმეს აკეთებენ. ეს Thread-ები ხშირ შემთხვევაში ხელთავიდან გამოიყენება და მათი რაოდენომა მერყეობს 1 დან 32767-ის ჩათვლით
- IO Threads - ეს Thread-ები გამოყოფილნი არიან მომუშავე Thread-ებისგან და ისინი მხოლოდ ინფომრაციის შეტანა , გამოტანის ოპერაციებზე ზრუნავენ და უბრუნდებიან `ThreadPool-ს` როდესაც შესრულების პორტი ( IOCP)შეატყობინებთ მათ
- Thread Injection Logic - გულისხმობს Thread-ების დინამიურად შექმნას თუ CPU გადატვითულია , მომუშავე Task-ები ლოდინის პროცესშია ან გაჯერებულია.


Thread Pool-ი ჩაშენებულია CLR-ში და თითო CLR-ს მხოლოდ ერთი Thread Pool შეიძლება ჰქონდეს და ის ზიარდება მთელი `AppDomain-ისთვის` . როდესაც CLR-ს ჩატვირთავს ოპერაციული სისტემა თავდაპირველად მისი Thread Pool-ი ცარიელია . შინაგანად Thread Pool-ს გააჩნია თავის მოთხოვნების რიგი , როდესაც ჩვენ რაიმე ასინქრონული ოპერაციის შესრულება გვსურს ვიძახებთ რაიმე მეთოდს ამისთვის ეს მეთოდი ვარდება ამ Thread Pool-ის მოთხოვნების რიგში. Thread Pool-ის კოდი ამოიღებს ამ რიგიდან ჩანაწერს და გაუგზავნის მას Thread Pool-ში არსებულ თავისუფალ Thread-ს . თუ არ გვაქვს თავისუფალი Thread-ი მაშინ ახალი იქმნება , ეს საბოლოო ოპერაციული სისტემი API-ის დახმარებით ხდება . ამ ახალი Thread-ის შექმნას წარმადობის ვარდნა მოსწევს , მაგრამ საქმის შესრულების შემდეგ ის არ ნადგურდება , ის უბრალოდ Thread Pool-ს უბრუნედება . ამ პოზიციაში მყოფ Thread-ს idle ეწოდება და თუ დიდი ხანი იყო ის ამ მდგომარეობაში (მაგ. 20 წამი ვინდოუსზე) - ის თავისუფლდება ადგილის გათავისუფლების მიზნით.


## Foreground Threads vs. Background Threads

CLR-ისთვის ყველა Thread-ი უნდა იყოს წინა ან უკანა ფონის . აქ წინა ფონის Thread-ები პრიორიტეტულად ითვლება და თუ CLR დაინახავს რომ ყველა წინა ფონის Thread-ი დამთავრდა ის პროგრამის მუშაობას შეწყვეტს იმის მიუხედავად უკანა ფონის Thread-მა დაასრულა თუ არა მუშაობა , შესაბამისად წინა ფონის ოპერაციუები უნდა იყოს მნიშვნელოვანი მაგალითად მეხსიერების ბაფერიდან  მონაცემების წაშლა დისკზე . 


## Thread-ების მექანიკური შექმნა vs ავტომატური შექმნა

Thread-ების შექმნა შეგვიძლია ორ ნაირად ესენია მექანიკურად (new Thread-ის გამოყენებით) და ავტომატურად (`ThreadPool.QueueUserWorkItem`ან `Task.Run`)ის გამოყენებით .  მექანიკური შექმნის დროს კი გვაქვს უფრო დიდი კონტროლი Thread-ზე , მაგრამ ეს უფრო დიდი კონტროლი მაინც და მაინც კარგი რამ არარის , მაგალითად როდესაც Thread-ს შექმნი მექანიკურად ის ავტომატურად არის წინა ფონის , კი შეგვიძლია ეს შევცვალოთ მაგრამ ის დამატებით კონფიგურაციას მოითხოვს , ასევე Thread-ის შექმნა მექანიკურის დროს ხდება პირდაპირ ის არ აკვირდება სისტემის მოთხოვნას და პირდაპირ ქმნის Thread-ს რამაც სასურველზე მეტი რესურსი შეუძლება წაგვართვას , მაგრამ ავტომატური Thread-ის შექმნის დროს Thread-ი არის უკანაფონის და სისტემას არ აიძულებს მასზე დალოდებას თუ სპეციალურ საკვანძო სიტყვას არ გამოვიყენებთ , ასევე ის უკვე არსებულ Thread-ებს ხელთავიდან ამუშავებს და ყოველ მოთხოვნაზე არ ქმნის ახალ Thread-ს . თუ მაინც მოუწია ახალის შექმნა ის პირდაპირ არ შექმნის Thread-ს და იყენებს კლდეზე აძრომის ასევე ცნობილი როგორც "Hill-Climbing"-ის ალგორითმს . მაგალითად აპლიკაციიდან შემოვიდა 10 ახალი Thread-ის შექმნის ბრძანება ,ჩვენ რომ აპლიკაციას 10 ახალი Thread-ი შევუქმნათ უკვე  10 MB დავკარგავთ ამიტომ thread Pool არ ქმნის 10-ივე Thread-ს ერთდროულად ის ჯერ ერთს შექმნის და დაელოდება უკვე რომელი არსებული Thread-ი გათავისუფლდა თუ არა შექმნის მეორეს და ასე შემდეგ. ანუ თითქმის ყოველთვის ჯობია რომ Thread Pool -ი გამოვიყენოთ.
## TPL

TPL - იგივე როგორც დავალებების პარალელური ბიბლიოთეკა , გამოიგონა მაიქროსოფტმა 2010 წელს .NET Framework 4.0-თან ერთად , რომელიც შეიქმნა აპლიკაციაში პარალელურობისა და ერთდროულობის გასამარტივებლად . ზოგადად ის წამოადგენს Thread-ების მაღალი დონის აბსტრაქციას , რომელიც დეველოპერებს ეხმარება უფრო ეფექტური , მასშტაბირებადი და შენარჩუნებადი პარალეური კოდის დაწერაში.

**შექმნის მიზეზი**

ტრადიციულ Thread-ებს გააჩნდათ თავის პრობლემები  მაგალითად :
- Thread-ის მართვის სირთულე - ოპერაციული სისტემიდან პირდაპირ Thread-ებზე მანიპულირება ძალიარ დიდ სირთულეს წარმოადგენდა და ერორების დაშვებაც ხშირი იყო.
- აპარატურის ოფტიმიზაცია - რაც მრავალბირთვიანი პროცესორები შეიქმნა დეველოპერებისთვის საჭირო გახდა თანამედროვე ინსტრუმენტები , რათა ახალი მრავალბირთვიანობის ფუნქციონალების გამოყენება შეძლებოდათ.
- წარმადობის მასშტაბირება - ტრადიციული Thread-ის მოდელი არ იყო შექმნილი თანამედროვე მრავალ ბირთვიანი პროცესორებისთვის
- საერთო ნიმუშები - ბევრი პარალელური ოპერაცია მიჰყვებოდა საერთო ნიმუშებს, რომელთა აბსტრაქციაც შესაძლებელი იყო.
- ასინქრონული პროგრამირება -  საჭირო იყო უკეთესი მხარდაჭერა ასინქრონული ოპერაციებისთვის Begin/End pattern-ის მიღმა.


TPL გახდა  `ThreadPool.QueueUserWorkItem`-ის კარგი ალტერნატივა , რომელიც გვთავაზობდა უფრო მაღალი დონის აბსტრაქციას , მას უფრო უკეთესი პროგრამირების მოდელი ქონდა რამაც წარმადობა გაზარდა . ის უფრო ეფექტურად  გეგმევდა და Thread pool-თან უფრო ჭკვიანურად ურთიერთქმედებდა , ასევე TPL მხარს უჭერდა `async/await`-ს და LINQ-ს. TPL მა შემოიტანა გაუქმების ტოკენიც.

## `Async/Await`

`Async/Await` -  არის ის საკვანძო სიტყვები , რომლებმაც ასინქრონული პროგრამირება შეცვალა .NET-ში .ის დაემატა C# 5.0 (>NET Framework 4.5) -თან ერთად , როგორც TPL-ზე ენის დამატებული აბსტრაქცია . TPL-ისგან მოწოდებულ Task კლასი იყო ოპერაციის ასუნქრონულად წარმოდგენის საშუალება , ხოლო `async/await`-მა ასინქრონული პროგრამირება დინამიურად უფრო ხელვმისაწვდომი გახადა.

მათი შექმნის მიზეზი რამოდენიმე იყო , მაგალითად :
- Callback Hell - მეთოდებში ჩადებული Callback-ები კოდს რთულად წასაკითხსა და შესანარჩუნებელს ხდიდა.
- შეცდომების პოვნა - ასინქრონულ კოდსში ძალიარ რთული იყო კონკრეტული ერორების დაჭერა.
- სინქრონიზაციის კონტექსტი - Thread Switching-ის მექანიკურად გაკეთება შეცდომებისკენ იყო მიდრეკილი.
- კომპოზიცია - რამოდენიმე ასინქრონული ოპერაციის კომბინაცია მოუხერთებელი იყო.

Task.Run-ით გამოძახებული ან შექმნილი Thread-ი არის ავტომატურაად უკანა ფონის და მასზე დასალოდებლად გამოიგონეს ეს Await საკვანძო სიტყვა.


## synchronization primitives

სინქრონიზაციის პრიმიტივები არის დაბალი დონის სამშენებლო ბლოკები , რომლებიც აკონტროლებენ გაზიარებულ რესურსზე წვდომას Thread-ებს შორის. ისინი გვიცავენ **prevent race conditions**, **data corruption**, და **ensure proper execution order**

- **prevent race conditions** - არის შემთხვევა , როდესაც ორი ან მეტი Thread-ი ცდილობს გაზიარებული მონაცემზე ზვდომას . Thread-ები მუშაობს პარალელურად და შეიძლება ერთისგან გაკეთებულმა ცვლილებამ მეორეს შეუშალოს ხელი

მაგალითად :

`int counter = 0;`

void Increment() {
    for (`int i = 0; i < 1000; i++`) {
        counter++; 
    }
}


ეს კოდი არ არის Thread-safe   

- **Prevent Data Corruption** - ხდება როდესაც რამოდენიმე Thread-ი ერთ დროულად ახორცილებე წაკითხვა/ჩაწერის ოპერაციას, რომელიც იწვევს შეუსაბამო ან არასწორ მნიშვნელობებს.

`List<int> numbers = new List<int>();`

void `AddNumber(int x)` {
    `numbers.Add(x)`; 
}


- Ensure Proper Execution Order - გვაქვს შემთხვევები , როდესაც ოპერაციების თანმიმდებრობას მნიშვნელობა აქვს , ზოგჯელ საჭიროა რომ ერთი Thread დაელოდოს მეორეს რათა მუშაობა გააგრძელოს.

ამ პრობლემების გადასაჭრელად გვაქვს რამოდენიმე არჩევანი.

### Lock / Monitor

ორივე Lock და Monitor-ი არის სინქრონიზების პრიმიტივები .NET-ში და შექმნილია ურთიერთგამორიცხვადი შესრულებისთვის . რაც გულისხმობს რომ მხოლოდ ერთ Thread-ს შეუძლია კრიტიკულ სექციაში შესვლა მოცემულ დროს. 

რეალურად Lock შემოკლებული სინტაქსია Monitor-ის , რომლეის დახმარებით შექგვიძლია ჩავკეტოთ ობიექტი და მოცემულ მომენტში მხოლოდ ერთ Thread-თან ვამუშაოთ.

object _lock = new object();

`void DoWork()` {
    lock (_lock) {
        
        `Console.WriteLine("Working...");`
    }
}

მონიტორის კლასი არის შედარებით დაბალი დონის კონტროლორი , რომელიც lock-ს იღებს ტაიმაუტით TryEnter-ის გამოყენებით

object _lock = new object();

void DoWork() {
    Monitor.Enter(_lock);
    try {
        Console.WriteLine("Working...");
    }
    finally {
        `Monitor.Exit(_lock);`
    }
}

ეს კოდი ჩაანაცვლებს Lock-ს


if (Monitor.TryEnter(_lock, TimeSpan.FromSeconds(1))) {
    try {
        Console.WriteLine("Got the lock!");
    }
    finally {
        Monitor.Exit(_lock);
    }
} else {
    `Console.WriteLine("Could not acquire lock in time.");`
}


აქ უკვე ტაიმერია გამოყენებული


### Mutex

Mutex (Mutual Exclusion) - არის ისევ ერთი სინქრონული პრიმიტივი როგორც lock , მაგრამ აქვთ განსხვავება . Lock-ს შეუძლია აკონტროლოს ერთ პროცესის ფარგლებში არსებული Thread-ების  რესურსზე წვდომა , ხოლო Mutex-ს დამატებით შეუძლია უკვე პროცესებს შორის რესურის გაცვლის კონტროლი.

ზოგადად პროცესებს აქვთ თავის ვირტუალური აიდი მინიჭებული , ეს ხდება იმისათვის რომ შემთხვევით არ მომხდეს მათ შორის ინფორმაციის გაცვლა , მაგრამ აბა როგორ ახერხებს ამას Mutex-ი?

Mutex-ი ქმნის სპეციალურ Karnel-ის ობიექტს , რომელსაც აკონტროლებს ოპერაციული სისტემა და ის მდებარეობს Kernel-ის რეჟიმის მეხსიერებაში.

და წარმოადგენს მესამე პირს რომელთან წვდომაც შეუძლიათ პროცესებს დაცულად.


// App1.exe and App2.exe – both contain this code
using System;
using System.IO;
using System.Threading;

class Program
{
    static void Main()
    {
        string filePath = "shared.txt";

        using var mutex = new Mutex(false, "Global\\MyFileWriteMutex");

        Console.WriteLine("Waiting for mutex...");

        mutex.WaitOne(); // Request ownership (will block if another process has it)

        try
        {
            Console.WriteLine("Writing to file...");
            File.AppendAllText(filePath, $"Written by {Environment.ProcessId} at {DateTime.Now}\n");
        }
        finally
        {
            mutex.ReleaseMutex(); // Important! Let others use it
            Console.WriteLine("Released mutex.");
        }
    }
}


თუ ის აპლიკაციები რომლებას უნდათ რომ Mutex-ი გამოიყენონ იზიარებენ სახელს მაშინ ისინი ერთ Mutex-ზე შეძლებენ წვდომას.