
ჩვენ უკვე ამოვწურეთ Runtime-ის მთავარი კომპონენტები და დროა გადავიდეთ მის დამხმარე ჩაშენებულ სერვისებზე , პირველ რიგში განვიხილოთ Garbage Collector-ი.

***რა არის GC ?***
Garbage Collector - იგივე რაც ნაგვის ამგროვებელი არის კომპიუტერის მეხსიერების მართვის ავტომატური სისტემა , რომელიც შეიძლება იყოს ცალკეული პროგრამა ან Runtime-ის ის ნაწილი , რომელიც ავტომატურად უბრუნებს მოწყობილობის მეხსიერებას . GC ამოიცნობს იმ მეხსიერებას რომელიც აღარ გამოიყენება აპლიკაციის მიმართ მას ჩათვლის როგორც Garbage და უბრუნებს მოწყობილობას.
### ისტორია

Garbage Collector -ი პირველად გამოიგონა John McCarthy-მ 1959 წელს დაპროგრამების ენა Lisp-ისთვის . Lisp-ი აწყობილი იყო სიმბოლოების გამოხატვაზე იგივე Linked list-ზე და მისი მეხსიერების მექანიკურად მართვა ძალიან რთული იქნებოდა, შესაბამისად John McCarty-იმ გამოიგონა გასაწმენდი მეხსიერების კვალის მიგნების ტექნიკა სახელად Mark and Sweep სადაც პირველ ეტაპზე ხდება ყველა მიწვდომაგი ობიექტის მონიშვნა (Marked) და შემდეგ ეტაპზე ოპერატიულ მეხსიერებაზე გადაყოლა და იმ მეხსიერების მოშორება რომელიც არ იყო Marked ამას ქვია Sweep .

ეს გამოგონება რათქმანუნდა რევოლუციური იყო მაგრამ ასევე წარმოუდგნლად ძვირიც , რის გამოც დაპროგრამების ენების უმეტესობამ როგორიც იყო C , Fortran , Pascal -მა ის არ ჩააშენეს თავიანთ სისტემებში და მექანიკური მეთოდი აირჩიეს.


***რისთვის გვჭირდება Garbage Collection?***

ისეთ დაპროგრამების ენებში სადაც არ გვაქვს ავტომატური Garbage Collection-ი (მაგ .. C/C++)- დეველოპერებს უწევდათ მეხსიერების მექანიკურად გამოყოფა ისეთი საკვანძო სიტყვებით როგორიცაა malloc() ან new და შემდეგ უწევდათ ამ მეხსიერების გათავისუფლება free() ან delete-ით. მექანიკურობის გამო შეცდომები ხშირი იყო ჩამოვთვლი ყველაზე ხშირად მომხდარ შეცდომებს

- Memory leaks - მეხსიერების გაჟონვა არის ის მოვლენა  ,როდესაც მექანიკურად გამოყოფილი მეხსიერების გათავისუფლება არ მომხდარა.
- Dangling pointers - ჩამოკიდებული პოინტერები არის ის მოვლენა , როდესაც მექანიკურად გამოყოფილი მეხსიერება ადრე გათავისუფლდა და ფოინთერი მას ისევ უყურებს.
- Double frees - მეხსიერების ორჯელ გათავისუფლება


Garbage Collector-ებმა პოპულარობა 90-იან წლებში მოიპოვა უფრო კონკრეტულად კი Java-ს გამოსვლისას (1995) , სადაც ჯავამ შემოიღო სლოგანი "დარეწე ერთხელ , გაუშვი ყველგან".
GC-ის დახმარებით ბევრად მარტივი გახდა type-safe ,memory-safe და multithreaded აპლიკაციების შექმნა.

არსებობს 5 ყველაფე გავრცელებული სტრატებია ნაგვის ამგროვებელი ესენია
- Mark-and-Sweep
- Reference Counting
- Generational GC
- Concurrent / `Paraller` GC
- Incremental or `Real-TIme` GC

ყოველი მათგანი ძალიან საინტერესოა მაგრამ C#-ის კონტექსტიდან ძალიან არ მინდა გადავუხვიო.

### C# და Garbage Collection

აღსანიშნავი ფაქტია რომ თანამედროვე დაპროგრამების ენებში C#-ს ერთ-ერთი ყველაზე მაღალი დონის და ეფექტული GC-აქვს ის შექმნილია მაღალი წარმადობისთვის ,დაბალი პაუზის დროსთვის და სიმარტივისთვის.

C# აერთიანებს 3 სახის GC ტექნიკას ესენია : Generational ,Concurrent/Parallel და Background-ს.


***Generational GC***

ამ სახის ნაგვის ამგროვებელს ეწოდა თაობათა რადგან ის ორგანიზებას აკეთებს ასაკის მხრივს  და სამ თაობად ყოფს ობიექტებს . ეს ყველაფერი წარმადობის ოფტიმიზაციისთვის ხდება.

მოდით პარალელი გავავლოთ სახლის დალაგებასთან . თუ ყოველ დღე სახლის ყველა ოთახს დავალაგებთ ჩვენ ძალიან დიდ დროს დავკარგავთ , მაგრამ თუ დავაკვირთებით და გავიგებთ რომ მაგალითად სამზარეულო ყველაზე ხშირად ისვრება , მისაღები ოთახი იშვიათად და გარაჟი თითქოს არასდროს  , მაშინ უფრო მარტივი ხდება თუ რომელ ადგილს სჭირდება უფრო ყურადღების მიქცევა . ანუ რატომ უნდა დავალაგო ყოველდღე მისაღები თუ ის თითქმის ყოველთვის სუფთაა .

დაახლოებით ასე მოქმედებს თაობათა ნაგვის ამგროვებელიც.

- *პირველი თაობა* (Gen 0) - ეს არის დამწყებითი თაობა სადაც ყველა ობიექტი იყრის თავდაპირველად თავს , ის ზომაში პატარაა და მისი დასკანერება ხშირად ხდება , ობიექტების 80-90% ამ თაობას ვერ სცდება . 

	"ჩავთავლოთ რომ ეს არის ის ნივთები , რომლებსაც ერთჯერადი გამოყენების შემდეგ ვიშორებთ თავიდან , მაგალითად პლასმასის ბოთ₾ები , კბილის გამოსაწმენდი ძაფები და ასე შემდეგ."

- *მეორე თაობა (Gen 1)* - ის ობიექტები , რომლებიც გადაურჩებიან პირველი თაობის სკანირებას გადაადგილდებიან მეორე თაობაში.

	"აქ იყრის ისეთი ნივთები თავს რომლებსაც ვინახავთ იმ იმედით რომ ერთ დღეს გამოგვადგება მაგალითად სახრახნისი , ჭანჭიკი ან რაიმე მსგავსი რამ".

- *მესამე თაობა (Gen 2)* - მეორე თაობაში თუ რამოდენიმე სკანირებას გადაურჩა ობიექტი ის გადადი მესამე თაობაში სადაც  ნაგვის ამგროვებელი ვარაუდობს რომ აქ მოხვედრილი ობიექტები დიდი ხანი იცოცხლებს 

	"წარმოვიდგინოთ ის ნივთები , რომლებიც სახლში დიდი ხანი გვაქვს მაგალითად : ტელევიზორი , მაცივარი , გაზქურა და ასე შემდეგ".


ეხლა შევეხები უშუალოდ დასკანერების პროცესს , თუ როგორ ხვდება ნაგვის ამგროვებლი თუ რომელი ობიექტის მეხსიერება გაათავისუფლოს და რომლის დაიტოვოს.

ეს ეტაპი იყოფა 4 ფაზად 

- ფესვების ძებნა 
- მისაწვდომი ობიექტების აღმოჩენა
- დასუფთავება და შეგროვება
- მეხსიერების შეკუმშვა


