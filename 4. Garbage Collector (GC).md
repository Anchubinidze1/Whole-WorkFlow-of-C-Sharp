
ჩვენ უკვე ამოვწურეთ Runtime-ის მთავარი კომპონენტები და დროა გადავიდეთ მის დამხმარე ჩაშენებულ სერვისებზე , პირველ რიგში განვიხილოთ Garbage Collector-ი.

***რა არის GC ?***
Garbage Collector - იგივე რაც ნაგვის ამგროვებელი არის კომპიუტერის მეხსიერების მართვის ავტომატური სისტემა , რომელიც შეიძლება იყოს ცალკეული პროგრამა ან Runtime-ის ის ნაწილი , რომელიც ავტომატურად უბრუნებს მოწყობილობის მეხსიერებას . GC ამოიცნობს იმ მეხსიერებას რომელიც აღარ გამოიყენება აპლიკაციის მიერ მას ჩათვლის როგორც Garbage და უბრუნებს მოწყობილობას.
### ისტორია

Garbage Collector -ი პირველად გამოიგონა John McCarthy-მ 1959 წელს დაპროგრამების ენა Lisp-ისთვის . Lisp-ი აწყობილი იყო სიმბოლოების გამოხატვაზე იგივე Linked list-ზე და მისი მეხსიერების მექანიკურად მართვა ძალიან რთული იქნებოდა, შესაბამისად John McCarty-იმ გამოიგონა გასაწმენდი მეხსიერების კვალის მიგნების ტექნიკა სახელად Mark and Sweep სადაც პირველ ეტაპზე ხდება ყველა მიწვდომაგი ობიექტის მონიშვნა (Marked) და შემდეგ ეტაპზე ოპერატიულ მეხსიერებაზე გადაყოლა და იმ მეხსიერების მოშორება რომელიც არ იყო Marked ამას ქვია Sweep .

ეს გამოგონება რათქმანუნდა რევოლუციური იყო მაგრამ ასევე წარმოუდგნლად ძვირიც , რის გამოც დაპროგრამების ენების უმეტესობამ როგორიც იყო C , Fortran , Pascal -მა ის არ ჩააშენეს თავიანთ სისტემებში და მექანიკური მეთოდი აირჩიეს.


***რისთვის გვჭირდება Garbage Collection?***

ისეთ დაპროგრამების ენებში სადაც არ გვაქვს ავტომატური Garbage Collection-ი (მაგ .. C/C++)- დეველოპერებს უწევდათ მეხსიერების მექანიკურად გამოყოფა ისეთი საკვანძო სიტყვებით როგორიცაა malloc() ან new და შემდეგ უწევდათ ამ მეხსიერების გათავისუფლება free() ან delete-ით. მექანიკურობის გამო შეცდომები ხშირი იყო . ჩამოვთვლი ყველაზე ხშირად მომხდარ შეცდომებს

- Memory leaks - მეხსიერების გაჟონვა არის ის მოვლენა  ,როდესაც მექანიკურად გამოყოფილი მეხსიერების გათავისუფლება არ მომხდარა.
- Dangling pointers - ჩამოკიდებული პოინტერები არის ის მოვლენა , როდესაც მექანიკურად გამოყოფილი მეხსიერება ადრე გათავისუფლდა და ფოინთერი მას ისევ უყურებს.
- Double frees - მეხსიერების ორჯელ გათავისუფლება


Garbage Collector-ებმა პოპულარობა 90-იან წლებში მოიპოვა უფრო კონკრეტულად კი Java-ს გამოსვლისას (1995) , სადაც ჯავამ შემოიღო სლოგანი "დარეწე ერთხელ , გაუშვი ყველგან".
GC-ის დახმარებით ბევრად მარტივი გახდა type-safe ,memory-safe და multithreaded აპლიკაციების შექმნა.

არსებობს 5 ყველაზე გავრცელებული სტრატეგია ნაგვის ამგროვებელი ესენია
- Mark-and-Sweep
- Reference Counting
- Generational GC
- Concurrent  or `Paraller` GC
- Incremental or `Real-TIme` GC

ყოველი მათგანი ძალიან საინტერესოა მაგრამ C#-ის კონტექსტიდან ძალიან არ მინდა გადავუხვიო.

### C# და Garbage Collection

აღსანიშნავი ფაქტია რომ თანამედროვე დაპროგრამების ენებში C#-ს ერთ-ერთი ყველაზე მაღალი დონის და ეფექტული GC-აქვს ის შექმნილია მაღალი წარმადობისთვის ,დაბალი პაუზის დროსთვის და სიმარტივისთვის.

C# აერთიანებს 3 სახის GC ტექნიკას ესენია : Generational ,Concurrent/Parallel და Background-ს.


***Generational GC***

ამ სახის ნაგვის ამგროვებელს ეწოდა თაობათა რადგან ის ორგანიზებას აკეთებს ასაკის მხრივს  და სამ თაობად ყოფს ობიექტებს . ეს ყველაფერი წარმადობის ოფტიმიზაციისთვის ხდება.

მოდით პარალელი გავავლოთ სახლის დალაგებასთან . თუ ყოველ დღე სახლის ყველა ოთახს დავალაგებთ ჩვენ ძალიან დიდ დროს დავკარგავთ , მაგრამ თუ დავაკვირთებით და გავიგებთ რომ მაგალითად სამზარეულო ყველაზე ხშირად ისვრება , მისაღები ოთახი იშვიათად და გარაჟი თითქოს არასდროს  , მაშინ უფრო თვალსაჩინა რომელ ადგილს სჭირდება უფრო ყურადღების მიქცევა . ანუ რატომ უნდა დავალაგო ყოველდღე გარაჟი თუ ის თითქმის ყოველთვის სუფთად რჩება .

დაახლოებით ასე მოქმედებს თაობათა ნაგვის ამგროვებელიც.

- *პირველი თაობა* (Gen 0) - ეს არის დამწყებითი თაობა სადაც ყველა ობიექტი იყრის თავდაპირველად თავს , ის ზომაში პატარაა და მისი დასკანერება ხშირად ხდება , ობიექტების 80-90% ამ თაობას ვერ სცდება . 

	"ჩავთავლოთ რომ ეს არის ის ნივთები , რომლებსაც ერთჯერადი გამოყენების შემდეგ ვიშორებთ თავიდან , მაგალითად პლასმასის ბოთლები , კბილის გამოსაწმენდი ძაფები და ასე შემდეგ."

- *მეორე თაობა (Gen 1)* - ის ობიექტები , რომლებიც გადაურჩებიან პირველი თაობის სკანირებას გადაადგილდებიან მეორე თაობაში.

	"აქ იყრის ისეთი ნივთები თავს რომლებსაც ვინახავთ იმ იმედით რომ ერთ დღეს გამოგვადგება მაგალითად სახრახნისი , ჭანჭიკი ან რაიმე მსგავსი ნივთი".

- *მესამე თაობა (Gen 2)* - მეორე თაობაში თუ რამოდენიმე სკანირებას გადაურჩა ობიექტი ის გადადი მესამე თაობაში სადაც  ნაგვის ამგროვებელი ვარაუდობს რომ აქ მოხვედრილი ობიექტები დიდი ხანი იცოცხლებს 

	"წარმოვიდგინოთ ის ნივთები , რომლებიც სახლში დიდი ხანი გვაქვს მაგალითად : ტელევიზორი , მაცივარი , გაზქურა და ასე შემდეგ".


ეხლა შევეხები უშუალოდ დასკანერების პროცესს , თუ როგორ ხვდება ნაგვის ამგროვებლი თუ რომელი ობიექტის მეხსიერება გაათავისუფლოს და რომლის დაიტოვოს.

ეს ეტაპი იყოფა 4 ფაზად 

- ფესვების ძებნა 
- მისაწვდომი ობიექტების აღმოჩენა
- დასუფთავება და შეგროვება
- მეხსიერების შეკუმშვა


## ფესვების ძებნა

ფესვების ძებნა იგივე რაც Root Scanning-ი არის სკანირების პირველი ფაზა , რომელიც განსაზღვრავს , თუ რომელი ობიექტებიდან უნდა დაიწყოს მეხსიერების სკანირება "ცოცხალი" ობიექტის გამოსავლენად. 
ამ ფაზაში GC პოულობს ყველა იმ დაწყებით წერტილს (იგივე root reference-ებს) , რომლიდანაც შესაძლებელია სხვა ობიექტებზე გადასვლა 


# **რომელი ობიექტებია ფესვური (.NET-ში)?**

1. **Stack variables (ლოკალური ცვლადები)**  
    Thread-ებზე არსებული call stack-ებში შენახული ცვლადები — ანუ ის რეფერენსები, რომლებიც ამჟამად გამოიყენება მოლოდინში მყოფი მეთოდების მიერ.
    
2. **CPU Registers-ში არსებული რეფერენსები**  
    ზოგჯერ პროცესორი ინახავს რეფერენსებს დროებით რეგისტრებში — ესეც ითვლება root-ად.
    
3. **Static variables**  
    სტატიკური ობიექტები ყოველთვის ითვლება root reference-ებად, რადგან ისინი დაკავშირებულნი არიან AppDomain-ის არსებობასთან და არ არის დამოკიდებული ინსტანცირებულ ობიექტებზე.
    
4. **GC Handle-ით შენახული ობიექტები**  
    ზოგიერთი ობიექტი შეიძლება იყოს `GCHandle`-ის მეშვეობით დაფიქსირებული (მაგალითად `Pinned` მდგომარეობაში), რათა GC-მა არ გადაადგილოს იგი.
    
5. **Finalizer queue-ში მყოფი ობიექტები**  
    ობიექტები, რომლებიც `Finalize()` მეთოდს იყენებენ, სანამ მოიშორება, GC-მა უნდა დაადგინოს მათი root-ებიდან ხელმისაწვდომობა.

მცირედით ავხსნი თუ როგორ მუშაობს ეს ფაზა

GC აანალიზებს თითოეულ thread-ს და ეძებს მის სტეკზე არსებულ რეფერენსებს , ამის შემდეგ ის ამოწმებს ყველა სტატიკურ ცვლადს და AppDomain-ის კონტექსტში არსებულ რეფერენსებს , ყოველი ნაპოვნი root-იდან GC იწყებს "mark" ფაზას იგივე ცოცხალი ობიექტების მონიშვნას.


         ┌──────────────┐              ┌──────────────┐
         │ Stack (root)│              │ Static (root)│
         └──────┬──────┘              └──────┬───────┘
                │                              │
                v                              v
          ┌───────────┐                  ┌───────────┐
          │ Object A  │                  │ Object B  │
          └─────┬─────┘                  └─────┬─────┘
                │                              │
                v                              v
          ┌───────────┐                  ┌───────────┐
          │ Object C  │                  │ Object E  │
          └───────────┘                  └───────────┘

         ┌───────────────┐
         │  Object D     │   <-- unreachable (will be collected)
         └───────────────┘


დიაგრამაზე წარმოდგენილია თუ როგორ აანალიზებეს ობიექტებს GC 
, ის იღებს ფესვურ ობიექტს და მიუყვება მაქედან სხვა ობიექტების რეფერენსებს და თუ რომელიმე ობიექტზე არ იყო რეფერებსი (როგორც დიაგრამაში D ობიექტი)  ის ჩაითვლება ნაგვად და აგროვდება GC-ის მიერ. 

## მისაწვდომი ობიექტების აღმოჩენა (Marking Phase)

მისაწვდომი ობიექტების აღმოჩენა არის GC სკანირების მეორე ეტაპი სადაც Rook სკანირებიდან ნაპოვნი ფესვებით ვპოულობთ ყველა ცოცხალ ობიექტს და მათ ცნითნავთ როგორც Marked , ანუ მოკლედ როგორც მუშაობს ფესვური ობიექტიდან გადავა სხვა დარეფერენსებულ ობიექტზე და მოძებნის და ამოწმებს ,მიუთითებს თუ არა ის მეხსიერების კონკრეტულ ობიექტზე . თუ მოუთითებს ნიშნავს (mark) მას , მონიშნული ობიექტიდან გადადის მის შვილობი ობიექტზე და მათაც ანალოგიურად ამოწმებს, ეს ობოექტი რეკურსიულად მიმდინარეობს მანამ სანამ ყველა ცოცხალი ობიექტი არ მოინიშნება .

## დასუფთავება და შეგროვება (Sweeping)

არის GC სკანირების მესამე ეტაპი სადაც GC გადადის მთელ მეხსიერების არეზე , ამოწმებს თითოეულ ობიექტს და განათავისუფლებს იმ ობიექტის მეხიერებას რომლებიც არ არიან მონიშნული როგორც mark .

ანუ, პროცესი ასე ვითარდება:  
**საწყის ეტაპზე ხდება ფესვების სკანირება**, რომლის დროსაც GC პოულობს იმ ძირითადი ობიექტების სიას (root objects), რომლებიც ყოველთვის უნდა ჩაითვალოს "ცოცხლად".  
ამის შემდეგ, იწყება **მონიშვნის ფაზა (Marking)** — GC ფესვებიდან იწყებს რეფერენცებით ყველა იმ ობიექტზე გადასვლას, რომელთაც მისაწვდომობა აქვთ ფესვებიდან და აღნიშნავს მათ როგორც ცოცხალს (mark).  
შემდეგი ეტაპია **დასუფთავება (Sweeping)**, სადაც ყველა ობიექტი, რომელიც მონიშნული არ არის (ანუ unreachable-ია), წაიშლება — უფრო სწორად, მათი მეხსიერება ბრუნდება ოპერატიული მეხსიერების (RAM) თავისუფალ უბნებში.


## მეხსიერების შეკუმშვა (Compacting Phase)
ეხსიერების შეკუმშვა არის GC-ის სკანირების მეოთხე და ბოლო ფაზა სადაც მეხსიერების გასუფთავების შემდეგ შესაძლებელია დარჩეს ბევრი "ხვრელი" - ანუ არაერთი მცირე თავისუფალი ბლოკი. ამან შესაძლოა დიდი ობიექტებისთვის ადგილის გამოყოფაში ხელი შეგვიშალოს ამ პრობლემის გადასაჭრელად არსებობს შეკუმშვის ფაზა.


ეხლა შესაძლებელია გაგიჩნდეთ ლოგიკური შეკითხვა როდის გადადის ობიექტი ერთი თაობიდან მეორეში?

ამაზე ბევრ სახელმძღვანელოში პასუხის არის სკანირების შემდეგ, მაგრამ ეს მაინც და მაინც სწორი არ არის , სკანირების ნაწილია შეკუმშვა , მაგრამ ეს ფაზა და სხვა თაობაში გადასხვა პარალელურად ხდება , ანუ შეკუმშვა იწყება და ამავდროულად გადადის გადარჩენილი ობიექტები სხვა თაობებში

ეხლა კიდევ ერთი უფრო საინტერესო შეკითხვა , Sweep- ის დროს G0-ში ხომ ხდება  მიუწვდომები ობიექტების  მეხსიერების გათავისუფლებადა და ამის შემდეგ "დაწინაურება" ანუ   გადარჩენილი ობიექტების შემდეგ თაობაში გადატანა , მაშინ რაღა საჭიროა ეს მეხსიერების შეკუმშვა თუ G0-ი ცარიელია?

საქმე ის არის რომ შეკუმშვა ეხება მთლიან Heap-ს და არა მხოლოდ G0-ს , ასევე კი ხშირ შემთხვევაში G0-მთლიანად იცლება მაგრამ არის შანსი რომ G0-ში ყველა გადარჩენილი ობიექტი არ გადავიდეს G1-ში

აქვე მინდა აღვნიშნო რომ ეს G0 , G1 , G2 არის Heap-ზე გამოყოფილი პატარა სეგმენტები , ეს სეგმენტრები როდესაც გაივსება მაშინ ხდება სკანირება 

მოდით მთლიან ჩარჩოს შევხედოთ ასე 

         +-----------------------------+
         |         Gen 2               |
         |   +---------------------+   |
         |   |      Gen 1          |   |
         |   |   +-------------+   |   |
         |   |   |   Gen 0     |   |   |
         |   |   +-------------+   |   |
         |   +---------------------+   |
         +-----------------------------+


შუაში არის Gen 0 პირველი თაობა რომელიც ყველაზე პატარა ზომისაა იქ მეხსიერება რომ შეივსება მაშინ იწყება სკანირება , თუ Gen 1 შეივსო აქაც დაიწყება სკანირება ოღონდ როგორც G1-ის ასევე G0-ის , თუ Gen 2 შეივსო მაშინ მთლიანად დასკანერდება სამივე თაობა.


## **Ephemeral vs large object heap (LOH)**

Ephemeral heap - სიტყვა Ephemeral ნიშნავს  ხანმოკლეს , ის არის Heap ის ნაწილი სადაც პატარა და ხანმოკლე ობიექტები ინახება ასეთებია Gen 0 , Gen 1. ყველა GC არის ამ Ephemeral Heap-ის ოფტიმიზირებაზე ორიენტირებული რადგან თანამედროვე პროგრამებში ძირითადად ასეთი ხანმოკლე ობიექტებს ვხდებით.

Large object heap -  ეს არის Heap-ზე ცალკე გამოყოფილი ადგილი სადაც ინახება დიდი ზომის ობიექტები , ანუ მნიშნველობა არ აქვს ეს ობიექტი დასკანერდა თუ არა ის ჩავარდება ამ ცალკეულ ჰიპში, ის მხოლოდ სკანირდება G2 სკანირების დროს 

აქ პრობლემას მალევე დაინახავდით ანუ დიდი ზომის ობიექტი შეიძლება ჩატვირთული მქონდეს ძალიან დიდი ხანი და მას არ გაწმენდს GC სანამ G2 არ გაივსება რაც არც თუ ისე ხშირად ხდება . თუ შენი აპლიკაცია მალევე არ ავსებს G2 ის მეხსიერებას ეს დიდი ზომის ობიექტი ჩათვალე მეხსიერებას გართმევს უმიზეზოდ ამ შემთხვევებში საჭიროა გავაკეთოთ მექანიკური გაწმენდს `GC.Collect();`


## **GC Handles** და **finalization**

`GCHandle` - არის მართულ ობიექტთან რეფერენსის შექმნის გზა , რისი დახმარებით უფრო პირდაპირ შეგვეძლება ამ ობიექტის მართვა . ძირითადად გამოიყენება ურთიერთქმედების სცენარებისთვის (მაგ., როდესაც საჭიროა მართულ მეხსიერებაზე მითითების გადაცემა არამართულ/მშობლიურ კოდში). ის მოთავსებულია `System.Runtime.InteropServices` namespace-ში.

GC ძირითადად ობიექტებს ამოძრავებს Heap-ში და შემდეგ ათავისუფლებს მათ მეხსიერებას თუ რეფერენსი ვერ ნახა. `GCHandle` - ის გამოყენებით შეგვიძლია რომ ხელი შევუშალოთ GC და ვერც გადაადგილოს და ვერც გაათავისუფლოს კონკრეტული ობიექტის მეხსიერბა.

არსებობს სუსტი , ძლიერი და მიმაგრებული Handle-ები

სუსტს - არ შეუძლია ობიექტების მეხსიერების გათავისუფლების შეჩერება , მაგრამ შეგვიძლია შევამოწმოთ ცოცხალია თუ არა.

ძლიერი -  არ მოგვცემს ნებას ობიექტის გათავისუფლებისა და გადაადგილების უფლება.

მიმაგრებული - მეხსიერების გადაადგილების საშუალებას გიგრძალავს მეხსიერებაში.