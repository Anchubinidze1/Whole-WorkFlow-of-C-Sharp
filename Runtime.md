ოპერაციულმა სისტემამ ჩაგვიტვირთვა PE (Portable Execution) ფაილი ან .NET assembly როგორც გინდათ ისე მოიხსენიეთ CLR-ში , უკვე აქიდან იწყება უკვე Runtime , პირველ რიგში რა არის ეს Runtime?

Runtime - Runtime არის გარემოსა და ამ გარემოში შემავალი სისტემის ისეთი კომპონენტები , რომლებიც პასუხისმგებელნი არიან პროგრამის გაშვებაზე . Runtime არის პროცესი , რომელიც გრძელდება პროგრამის დაწყებიდან დასრულებამდე .

- გარემო - Runtime-ის კონტექსტში გარემო არის ჩვენს მიერ გაშვებული პროგრამის მთლიანი კონტექსტი ან პლატფორმა და მასში მოთავსებულია ყველაფერი რას საჭიროა ამ პროგრამის გასაშვებად(Runtime engine , OS info, hardware info, libraries and framework , `ect..`).
- სისტემის კომპონენტები - არის გარემოში არსებული ცალკეული მოდულები , რომლებიც კონკრეტულ ფუნქციონალს გვაძლევენ იმისათვის რომ პროგრამის გაშვება გახდეს შესაძლებელი (JIT Compiler , Garbage Collector , Security Manager , Thread Manager , Other libraries).


## CLR Introduction

.NET ის პროდუქტების მთავარი Runtime ძრავი არის ცნობილი როგორც CLR (Common Language Runtime) , CLR ხშირად ეძახიან ვირტუალურ მანქანას და პარალელის გავლებას ცდილობენ JVM-თან (Java Virtual Machine) , მაგრამ CLR JVM-ისგან განსხვავდება იმით რომ მას არ ადარდებს თუ რომელ დაპროგრამების ენასთან მუშაობს , კომპილერი ყოველთვის CIL მისცემს მას , მაგრამ JVM მხოლოდ ჯავაზე მუშაობს , 

**ისტორიის მიმოხილვა**
სანამ ეს შუამდგომელ ენაში (IL) გადათარგმნა გვექნებოდა პროგრამების უმეტესობა იწერებოდა ისეთ დაპროგრამების ენემბში სადაც დაკომპილირებული კოდი პირდაპირ მანქანის ინსტრუქციებში გადადიოდა , ეს მიდგომა გვაძლევდა უფრო დაბალი დონის კონტროლს კომპონენტებზე და ასევე წარმადობითაც ისინი დღესაც ძალიან პოპულარულები არიან ( C / C++) , მაგრამ მათ თავიანთი მინუსები გააჩნდათ მაგალითად : დაპროგრამების ენები განსხვავებულ მანქანის კოდს ქმნიდნენ და მათი შეთავსება რთული იყო , ისინი დამოკიდებულნი იყვნენ პროცესორსა და ოპერაციულ სისტემებზე , დეველოპერს მეხსიერების მათვა თვითონ უწევდათ , განსხვავებულ აპპლიკაციებს განსხვავებული Runtime ბიბლიოთეკები ან DLL-ები სჭირდებოდათ რაც კომპლექსური იყო.

პირველად შუამგომელი ენის ფუნქციონალი ჩაინერგა დაპროგრამების ენა BCPS (Basic Combined Programming Language) იყო რომელიც 1960-იან წლებში შემუშავდა ეს კოდი გადასატანად შედარებით მარტივი გახადეს  და მისი სახელი O-code იყო, 1970-იან წლებში დაპროგრამების ენა Pascal-მა შემოიღო თავის შუამდგომელი კოდი რომელსაც P-code ეწოდა , მალევე SmallTalk-მა გამოუშვა  თავის შუამდგომელი კოდი რომელსაც Bytecode ეწოდა და ეს გახდა მომავალში Java-ს Bytecode-ის ფუძე რომელიც 1990-იან წლებში შეიქმნა და უკვე თანამედროვე Bytecode და JVM შემოგვთავაზა და ბოლოს მოვედით .NET CLR-ზე  რომელიც 2000 იან წლებში გამოვიდა , შუამდგომელ კოდს IL (Intermediate Language) უწოდეს და მისი მთავარი უპირატესობა იყო ის რომ დაპროგრამების ენისგან გამოუკიდებელი გახდა.


## CLI

CLI - CLI იგივე რაც Common Language Infrastructure არის გახსნილი სპეციფიკაცია და ტექნიკური სტანდარტების ნაკრები , შემქნელი არის მაიქროსოფთის მიერ და ის რეალურად აიმპლემენტირებს ორ მნიშვნელოვალ სტანდატიზაციას ესენია

- ISO/IEC 23271 - არის სტანდარტიზაციის საეთაშორისო ორგანიზაციისა და საერთაშორისო ელექტროტექნიკური კომიის გაერთიანება
- ECMA-335 - არის სტანდარტიზაცია , რომელიც განსაზღვრავს ტექნიკურ სპეციფიკაციას runtime გარემოსთვის , რომელიც საშუალებას გვაძლევს რომ განსხვავებულ მაღალი დონის დაპროგრამების ენებზე დაწერილი აპლიკაციები გაშვებულიყოს განსხვავებულ კომპიუტერულ პრათფორმებზე კოდზე შეუხებლად.



## CLR Core / Help-full services

CLR-ს მრავალი მნიშვნელოვანი საქმე აკისრია ის ზოგადად არის Runtime-ის მნიშნელოვანი სერვისების კომბინაცია , მაგრამ მე მაინც დავყოფ მათ ორ ნაწილად : Core , Help-full services.

**Core**
ზოგადად აუცილებელია რომ CIL გარდაიქმნას მანქანის კოდად ამის გამო მე Core კატეგორიაში ჩავსვავ ორ ფუნქციონალს პირველი არის JIT (Just in time Compiler) და Class Loader . JIT საჭიროა იმისთვის რომ მანქანის კოდად გარდაქმნა მოხდეს და Class Loader-ის გარეშე JIT ვერ იმუშავებს.

**Help-full services**
CLR-ს მოყვება მრავალი ძალიან დამხმარე სერვისი , როგორიცაა Garbage Collector , Security Manager , Exception Handling , Thread Manager , Interop Service , Metadata and Reflection , ეს სერვისები ძალიან საჭიროა და დიდ დროს აგებინებს დეველპერებს მაგრამ მათ გარეშეც შეიძლება მუშაობა


## Class Loader (Assembly Loader)

Class Loader-არის java-დან შემოსული ტერმინოლოგია , რომელიც აღწერს იმ მექანიზმს , რომელიც პასუხისმგებელია კლასების ან ზოგადად ტიპების ჩატვირთვაზე ოპერატიულ მეხსიერებაში , ის არის JRE(Java Runtime Environment) -ის ნაწილი და მუშაობს JVM(Java Virtual Machine)-თან.

.NET ის პროდუქტებს ასე პირდაპირ არ აქვთ Class Loader-ი . აქ  ტიპების ჩატვითვაზე ზრუნავს Assembly Loader-ი და მომავალში ის მანიპულირდება რეფლექციის დახმარებით.


Assembly Loader - არის პროცესი , რომელიც ტვირთავს საჭირო Assembly-ის ოპერატიულ მეხსიერებაში პროგრამის გაშვებისას . აქ assembly-ში იგულისხმება , როგორც კოდი , Dependencies , ვერსიები და ხელმისაწვდომი runtime-ი

Assembly Loader- გვთავაზობს რამოდენიმე მნიშვნელოვან  ფუნქციონალს ესენია :
- Dynamic Execution
- Efficiency
- Version Control
- Security

**Dynamic Execution**
`Dynamic Execution` - დინამიური შესრულება არის პროგრამის უნარი , გადაწყვიტოს რა კოდი უნდა შეასრულოს Runtime-ზე და არა დაკომპილირების დროს. ეს განსაკუთრებით გამოასდეგია იმ შემთხვევებში როდესაც საქმე გვაქვს : 
- უცნობ ტიპებთან - მაგალითად ისეთი სიტვაცია როდესაც კონკრეტულ კონდიშენალზე ცვლადი განსხვავებულ ტიპს იღებს.
- Plugins და გაფართოებებთან - მომხმარებლების ქმედებაზე დაყრდნობით რაღაც გარეგანი კოდის გამოყენება.
- რეფლექიასთან - რეფლექცია არის Runtime სერვისი , რომლის დახმარებით შეგვიძლია ტიპების მონიტორინგი და შეცვლაც Runtime-ზე. (უფრო ღრმად მომდევნო თავებში განვიხილავ)

**Efficiency**
`Efficiency` - ეფექტურობა დაპროგრამებაში მიუთითებს იმაზე თუ როგორ იყენებს სისტემა ისეთ რესურსებს როგორიცაა მეხსიერება და CPU. Assembly Loading-ში  ეფექტურობა კრიტიკულია რადგან ის ეხება :
- Memory Usage - Assembly Loading-ის დროს უნდა განისაზღვროს მნიშნელოვანი Assembly რომელია და მხოლოდ ისინი ჩაიტვირთოს რაც აპლიკაციის მეხსიერების ამცირებს
- Application Startup Time - Assembly-ის მხოლოდ საჭირო დროს ჩატვირთვა უმცირებს სისტემას ჩატვირთვის დროს .
- Lazy Loading - ესეც სტრატეგიული მიდგომაა სადაც საჭირო დროს მხოლოდ აპლიკაციის საჭირო ნაწილები იტვირთება რაც ერთდოულად ამწირებს  მეხსირების მოხმარებასაც და ჩატვირთვის დროსაც მისი გამოყენება **`Assembly.Load`** or **`Assembly.LoadFrom`** შეგვიძლია

**Version Control**
`Version Control` - ვერსიის კონტროლი Assembly Loading-ის კონტექტსში ნიშნავს იმ assembly-ების ვერსიების მართვას და კონტროლს , რომლებიც საჭირონი არიან აპლიკაციისთვის  . ზოგიერთი assembly-ის ვერსია სრულიად განსხვავებულია მისი სხვა ვერსიებისგან საჭიროა რომ ის კონკრეტული ვერსია გვქონდეს , რომელზეც ჩვენი აპლიაცია მუშაობს
- მაგალითად როდესაც ძველ კოდზე ვმუშაობთ მას დიდი ალბათობით არ ექნება ყველაზე ახალი დეფენდესები , მაგრამ ექნება ის ვერსიები , რომელზეც ის მუშაობს . ვერსიის განალებამ შესაძლოა კოდის ფუნქციონალი არიოს თუ მას  breaking changes- ქონდა ანუ მთლიანად შეიცალა ის მიდგომა რომლითაც პაკეტი პროექტს უკავშირდება.


.NET Framework-ში არსებობს სპეციალური რეპოზიტორი სახელად GAC (Global Assembly Cache) მას იყენებს Assembly loader-ი და GAC-ში ინახება ისეთი assembly-ები , რომლებიც რამოდენიმე აპლიკაციას უნდა გაუზიარდეს ერთ მანქანაზე . GAL-ის შექმნით უნდოდათ რომ DLL Hell-ის პრობლემები აერიდებინათ თავიდან სადაც განსხვავებულ აპლიკაციებს ერთი და იგივე assembly-სჭირდებათ მაგრამ განსხვავებული ვერსიებით.




